

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>straph.streaming_algorithms.fastest_path_algorithm &mdash; straph 1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> straph
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">straph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>straph.streaming_algorithms.fastest_path_algorithm</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for straph.streaming_algorithms.fastest_path_algorithm</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">jit</span>

<span class="kn">import</span> <span class="nn">pathlib</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">msgpack</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="k">import</span> <span class="n">SortedList</span><span class="p">,</span> <span class="n">SortedSet</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">lil_matrix</span>

<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">components</span> <span class="k">as</span> <span class="n">scc</span>
<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">stream</span> <span class="k">as</span> <span class="n">sg</span>
<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">dag</span> <span class="k">as</span> <span class="n">dg</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatch</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="c1">#######################################</span>
<span class="c1">#           Pre process functions</span>
<span class="c1">########################################</span>

<div class="viewcode-block" id="load_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.load_wcc">[docs]</a><span class="k">def</span> <span class="nf">load_wcc</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dict_offset_wcc</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">file_input</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">dict_offset_wcc</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
        <span class="c1"># assert i[0] == id_wcc</span>
        <span class="c1"># assert i[3] == tuple(sorted(i[3],key=lambda x:x[1]))</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">links</span></div>


<div class="viewcode-block" id="construct_index_node_to_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.construct_index_node_to_wcc">[docs]</a><span class="k">def</span> <span class="nf">construct_index_node_to_wcc</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">):</span>
    <span class="n">index_node_to_wcc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># print(&quot;idwcc :&quot;,id_wcc)</span>
            <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># print(&quot;links :&quot;,links)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">)</span>
                    <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index_node_to_wcc</span></div>


<div class="viewcode-block" id="get_node_presence"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.get_node_presence">[docs]</a><span class="k">def</span> <span class="nf">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">):</span>
    <span class="n">nodes_presence</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodes_presence</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nodes_presence</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nodes_presence</span></div>


<div class="viewcode-block" id="compute_augmented_neighborhood"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_augmented_neighborhood">[docs]</a><span class="k">def</span> <span class="nf">compute_augmented_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    On veut des segments de noeuds comme clefs ainsi que dans les voisins (b,e,v) : [(t0,t1,(nt0,nt1,u))] :)</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param node_presence:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># See &#39;neighborhood_with_node_presence&#39; in stream.py</span>
    <span class="k">if</span> <span class="n">node_presence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
    <span class="c1"># N = defaultdict(set)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">SortedSet</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="c1"># print(&quot; l :&quot;,l)</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">nu</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">nv</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="n">N</span><span class="p">[</span><span class="n">nu</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">nv</span><span class="p">))</span>
            <span class="n">N</span><span class="p">[</span><span class="n">nv</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">nu</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">N</span></div>


<span class="c1">#######################################</span>
<span class="c1">#       Plot functions                #</span>
<span class="c1">#######################################</span>


<div class="viewcode-block" id="plot_foremost_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.plot_foremost_path">[docs]</a><span class="k">def</span> <span class="nf">plot_foremost_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ttr</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                       <span class="n">col</span><span class="o">=</span><span class="s2">&quot;#8f246b&quot;</span><span class="p">,</span> <span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Draw a path on the Stream Graph S</span>
<span class="sd">    :param S: A Stream Graph</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="n">label_nodes_by_letters</span><span class="p">)</span>
    <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;id_wcc :&quot;</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="s2">&quot;id_scc :&quot;</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_storage_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">)</span>
        <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#4d79ff&#39;</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#00cc00&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">col</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span>
                                               <span class="p">))</span>
        <span class="c1"># Plot a single rectangle for COMP</span>
        <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.15</span><span class="p">),</span>
                                           <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                           <span class="n">height</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">,</span>
                                           <span class="n">edgecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                           <span class="n">facecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                           <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span>
                                           <span class="p">))</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="c1"># Plot temporal source and temporal destination</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000099&#39;</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ttr</span><span class="p">],</span> <span class="p">[</span><span class="n">destination</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#004d00&#39;</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Foremost Path from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_fastest_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.plot_fastest_path">[docs]</a><span class="k">def</span> <span class="nf">plot_fastest_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">latency</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                      <span class="n">col</span><span class="o">=</span><span class="s2">&quot;#8f246b&quot;</span><span class="p">,</span> <span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Draw a path on the Stream Graph S</span>
<span class="sd">    :param S: A Stream Graph</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="n">label_nodes_by_letters</span><span class="p">)</span>
    <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">source_comp</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scc_storage_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;id_wcc :&quot;</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="s2">&quot;id_scc :&quot;</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_storage_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">)</span>
        <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">source</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#4d79ff&#39;</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#00cc00&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">col</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span>
                                               <span class="p">))</span>
        <span class="c1"># Plot a single rectangle for COMP</span>
        <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.15</span><span class="p">),</span>
                                           <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                           <span class="n">height</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">,</span>
                                           <span class="n">edgecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                           <span class="n">facecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                           <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span>
                                           <span class="p">))</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="c1"># Plot temporal source and temporal destination</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">source</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000099&#39;</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">latency</span><span class="p">],</span> <span class="p">[</span><span class="n">destination</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#004d00&#39;</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Fastest Path from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<span class="c1">###############################</span>
<span class="c1">#       Loading functions     #</span>
<span class="c1">###############################</span>


<div class="viewcode-block" id="load_scc_from_msgpack"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.load_scc_from_msgpack">[docs]</a><span class="k">def</span> <span class="nf">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_storage</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">scc_storage</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">file_input</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">dict_offset_scc</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
        <span class="c1"># print(&quot;i :&quot;, i)</span>
    <span class="k">return</span> <span class="n">scc</span><span class="o">.</span><span class="n">strongly_connected_component</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">id_scc</span><span class="p">,</span>
                                            <span class="n">times</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                                            <span class="n">nodes</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="n">u</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]]),</span>
                                            <span class="n">links</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span></div>


<div class="viewcode-block" id="load_dag_links"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.load_dag_links">[docs]</a><span class="k">def</span> <span class="nf">load_dag_links</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">):</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dag_file</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">dag_file</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">id_wcc</span><span class="p">:</span>
                <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># viz.plot_condensation_dag_custom(id_wcc, nodes, links, scc_storage_path,</span>
                <span class="c1">#  dict_offset_scc_storage_path ,arrow=True)</span>
                <span class="c1"># plt.show()</span>
                <span class="k">return</span> <span class="n">links</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="k">return</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="load_condensation_dag"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.load_condensation_dag">[docs]</a><span class="k">def</span> <span class="nf">load_condensation_dag</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    TODO : Definir une limite pour ne charger le Dag que si il tient en mémoire (assez rare à riprio)</span>
<span class="sd">    :param id_wcc:</span>
<span class="sd">    :param dag_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">scc_dag</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dag_file</span><span class="p">:</span>
        <span class="n">dag_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">dict_offset_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">dag_file</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">id_wcc</span>
        <span class="n">dict_id_scc_to_c_node</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">c_node</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">)</span>
            <span class="n">dict_id_scc_to_c_node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_node</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">c_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">set_index_id_scc_to_scc</span><span class="p">(</span><span class="n">dict_id_scc_to_c_node</span><span class="p">)</span>
        <span class="c1"># G.plot_custom(arrow=True)</span>
        <span class="c1"># print(&quot;Id wcc :&quot;,id_wcc,&quot; nb nodes :&quot;,len(G.c_nodes),&quot; nb links :&quot;,len(G.c_links))</span>
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="load_condensation_dags"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.load_condensation_dags">[docs]</a><span class="k">def</span> <span class="nf">load_condensation_dags</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">):</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="n">dict_id_wcc_to_dag</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dag_file</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">dag_file</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
            <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">load_condensation_dag</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">dict_id_wcc_to_dag</span></div>


<div class="viewcode-block" id="compute_dict_offset_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_dict_offset_wcc">[docs]</a><span class="k">def</span> <span class="nf">compute_dict_offset_wcc</span><span class="p">(</span><span class="n">path_wcc_scf</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute offset of each dag in &#39;scc_dag.scf&#39;, in order to fast access a dag.</span>
<span class="sd">    :param path_scc_scf:</span>
<span class="sd">    :param storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">id_wcc_2_offset</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_wcc_scf</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">id_wcc_2_offset</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">storage_path</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">msgpack</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">id_wcc_2_offset</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">id_wcc_2_offset</span></div>


<div class="viewcode-block" id="compute_dict_offset_dag"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_dict_offset_dag">[docs]</a><span class="k">def</span> <span class="nf">compute_dict_offset_dag</span><span class="p">(</span><span class="n">path_scc_dag</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute offset of each dag in &#39;scc_dag.scf&#39;, in order to fast access a dag.</span>
<span class="sd">    :param path_scc_scf:</span>
<span class="sd">    :param storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dag_2_offset</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_scc_dag</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dag_2_offset</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">storage_path</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">msgpack</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dag_2_offset</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag_2_offset</span></div>


<div class="viewcode-block" id="compute_dict_offset_scc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_dict_offset_scc">[docs]</a><span class="k">def</span> <span class="nf">compute_dict_offset_scc</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute offset of each scc in &#39;scc.scf&#39;, in order to fast access a scc.</span>
<span class="sd">    :param path_scc_scf:</span>
<span class="sd">    :param storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">scc_2_offset</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>  <span class="c1"># SCC components are ordered by their end time</span>
            <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">scc_2_offset</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)]</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">storage_path</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">msgpack</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">scc_2_offset</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scc_2_offset</span></div>


<div class="viewcode-block" id="construct_index_node_to_scc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.construct_index_node_to_scc">[docs]</a><span class="k">def</span> <span class="nf">construct_index_node_to_scc</span><span class="p">(</span><span class="n">scc_storage</span><span class="p">):</span>
    <span class="n">index_node_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">scc_storage</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
            <span class="n">id_scc</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># print(&quot;idscc :&quot;, id_scc)</span>
            <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
                    <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
                    <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index_node_to_scc</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#           Fastest Path (Wu : https://www.vldb.org/pvldb/vol7/p721-wu.pdf)   #</span>
<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="remove_dominated_elements"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.remove_dominated_elements">[docs]</a><span class="k">def</span> <span class="nf">remove_dominated_elements</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">pred_av</span><span class="p">,</span> <span class="n">pred_lv</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">v</span><span class="p">])):</span>
        <span class="n">av</span><span class="p">,</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">pred_lv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;=</span> <span class="n">pred_av</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">pred_av</span> <span class="o">-</span> <span class="n">pred_lv</span> <span class="o">&lt;</span> <span class="n">av</span> <span class="o">-</span> <span class="n">lv</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">av</span><span class="p">,</span> <span class="n">lv</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">lv</span> <span class="o">==</span> <span class="n">pred_lv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;</span> <span class="n">pred_av</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">pred_av</span> <span class="o">-</span> <span class="n">pred_lv</span> <span class="o">&lt;</span> <span class="n">av</span> <span class="o">-</span> <span class="n">lv</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">av</span><span class="p">,</span> <span class="n">lv</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred_av</span> <span class="o">=</span> <span class="n">av</span>
            <span class="n">pred_lv</span> <span class="o">=</span> <span class="n">lv</span>
    <span class="n">M</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">to_remove</span></div>


<div class="viewcode-block" id="update_paths"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.update_paths">[docs]</a><span class="k">def</span> <span class="nf">update_paths</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Update L structure</span>
<span class="sd">    Elements of L are sorted by their starting time, (and the better the duration is the worse the arrival time is).</span>
<span class="sd">    We just need to add to L[v] the last element in L[u] before</span>
<span class="sd">    the beginning of the link (t0) and every other element during the link (from t0 to t1).</span>
<span class="sd">    :param M:</span>
<span class="sd">    :param t0:</span>
<span class="sd">    :param t1:</span>
<span class="sd">    :param u:</span>
<span class="sd">    :param v:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">last_elem</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">au</span><span class="p">,</span> <span class="n">su</span><span class="p">)</span> <span class="ow">in</span> <span class="n">M</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">:</span>  <span class="c1"># We have just added the last element of M[u] before the beginning of the link given the ordering of M.</span>
            <span class="n">new_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">su</span><span class="p">)</span>
            <span class="n">last_elem</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">new_start</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">t0</span> <span class="o">&lt;</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1">#  We take arrival times compatible with the link.</span>
            <span class="n">new_arrival</span> <span class="o">=</span> <span class="n">au</span>
            <span class="n">new_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">su</span><span class="p">)</span>
            <span class="n">M</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">new_arrival</span><span class="p">,</span> <span class="n">new_start</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">au</span> <span class="o">&gt;</span> <span class="n">t1</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">last_elem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">last_elem</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_latencies_in_wcc_wu"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_latencies_in_wcc_wu">[docs]</a><span class="k">def</span> <span class="nf">compute_latencies_in_wcc_wu</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    One pass algorithm to compute single source latenciesinside a WCC</span>
<span class="sd">    BFS like (to respect the temporal order of the links).</span>
<span class="sd">    We can visit each node several time, but we visit links only once !!</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param L:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># set of visited links</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">SortedSet</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">SortedSet</span><span class="p">()</span>
    <span class="c1"># Initialisation for the source</span>
    <span class="n">M</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># (arrival_time in destination, leaving_time from source)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">))</span>  <span class="c1"># (arrival_time, source)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">au</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># min_au = min([i[1] for i in L[u]])</span>
        <span class="c1"># print(&quot;u :&quot;,u)</span>
        <span class="n">visited_neihgbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">N</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># If we can take the link</span>
                    <span class="n">J</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="c1"># Get the best distances and arrival times compatible with the link !</span>
                    <span class="c1"># A better distance for &#39;v&#39; can exist but with a later arrival time which isn&#39;t compatible with the current link.</span>
                    <span class="n">update_paths</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="c1"># We must remove useless elements from L[v]:</span>
                    <span class="c1"># Every path that is a longer than a previous one and that arrives after or at the same time</span>
                    <span class="c1"># But we can keep longer paths that arrives before (in case of a shortcut link not yet analyzed)</span>
                    <span class="n">remove_dominated_elements</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_neihgbors</span><span class="p">:</span>
                        <span class="n">av</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">au</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">av</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                        <span class="n">visited_neihgbors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1"># Get the best latency realized sor far for each segment of nodes.</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># if len(v) &gt; 1:</span>
        <span class="c1">#     for i,l in enumerate(v):</span>
        <span class="c1">#         print(&quot;i :&quot;,i)</span>
        <span class="c1">#         print(&quot;latency :&quot;,l[1]-l[0])</span>
        <span class="c1">#</span>
        <span class="c1"># a = v[0][1]</span>
        <span class="c1"># l = v[0][0]</span>
        <span class="n">lambdas</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lambdas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
            <span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">duration</span><span class="p">)</span>
            <span class="c1"># print(&quot;a-s :&quot;,a-s)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
            <span class="c1"># print(&quot;a-s :&quot;, a - s)</span>
    <span class="c1"># print(&quot;L :&quot;,L)</span>
    <span class="k">return</span> <span class="n">L</span></div>


<div class="viewcode-block" id="compute_latencies_wu"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_latencies_wu">[docs]</a><span class="k">def</span> <span class="nf">compute_latencies_wu</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">,</span> <span class="n">id_wcc_to_node_presence</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single source computation of latencies (duration of any shortest path).</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param wcc_storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key : destination node ; value : latency</span>
    <span class="n">unvisited_wcc</span> <span class="o">=</span> <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="c1"># print(&quot;unvisited wcc :&quot;,unvisited_wcc)</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">for</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">unvisited_wcc</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">id_wcc_to_node_presence</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="c1"># Get potential Temporal Sources in WCC</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
        <span class="c1"># print(&quot;N augmented neighborhood :&quot;,N)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">compute_latencies_in_wcc_wu</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="c1"># print(&quot;sources :&quot;,sources)</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">return</span> <span class="n">L</span></div>


<span class="c1">#################################################</span>
<span class="c1">#           Paths Functions                     #</span>
<span class="c1">#################################################</span>


<div class="viewcode-block" id="compute_foremost_path_streaming"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_foremost_path_streaming">[docs]</a><span class="k">def</span> <span class="nf">compute_foremost_path_streaming</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">duration_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute a foremost path between &#39;source&#39; and &#39;destination&quot; starting at &#39;begin time&#39;.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print(&quot;Foremost path from &quot;, source, &quot; to &quot;, destination, &quot; starting at time &quot;, start)</span>

    <span class="c1"># Get starting component</span>

    <span class="k">if</span> <span class="n">start_comp</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="n">start_comp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
            <span class="c1"># TODO : We can load only if times[0]&lt;=start&lt;= times[1], presently we load it anyway</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[[</span><span class="n">id_scc</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id_wcc</span>
                <span class="n">start_comp</span> <span class="o">=</span> <span class="n">id_scc</span>
                <span class="k">break</span>
    <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not exist in the Stream Graph at time &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; !&quot;</span><span class="p">)</span>
    <span class="c1"># Iterate on link</span>
    <span class="c1"># Construct adjacency list (directed)</span>
    <span class="n">dag_links</span> <span class="o">=</span> <span class="n">load_dag_links</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">)</span>

    <span class="c1"># TODO : We shouldn&#39;t have to construct &#39;a_l&#39;, the adjacency list, every time.</span>
    <span class="n">a_l</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">end_time_comp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">dag_links</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dag_links</span><span class="p">:</span>
            <span class="c1"># ONLY IF the destination is accesible from begin time</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">a_l</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">end_time_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">duration_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">end_time_comp</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">duration_threshold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_time_comp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span>

    <span class="c1"># print(&quot;duration threshold :&quot;,duration_threshold)</span>
    <span class="c1"># print(&quot; a_l : &quot;, a_l)</span>

    <span class="c1"># Custom BFS on DAG</span>
    <span class="k">def</span> <span class="nf">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="n">path_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start_comp</span><span class="p">,</span> <span class="p">[</span><span class="n">start_comp</span><span class="p">])]</span>
        <span class="n">foremost_duration</span> <span class="o">=</span> <span class="n">duration_threshold</span>  <span class="c1"># This variable, once assigned, is used as a threshold (yeah)</span>
        <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
            <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># print(&quot; v : &quot;,v)</span>
            <span class="c1"># print(&quot; len path queue :&quot;,len(path_queue))</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
                    <span class="c1"># print(&quot; comp nodes :&quot;,comp.nodes)</span>
                    <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="c1"># print(&quot;PATH Found :&quot;,path)</span>
                        <span class="n">foremost_duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">foremost_duration</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">foremost_duration</span><span class="p">:</span>
                        <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]))</span>

    <span class="c1"># print(&quot; Start BFS&quot;)</span>
    <span class="n">foremost_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">foremost_paths</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">path_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">foremost_paths</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">path_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="c1"># print(&quot;Path times :&quot;, path_times)</span>
    <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path_times</span><span class="p">])</span>
    <span class="c1"># print(&quot;Foremost time : &quot;, min_t)</span>
    <span class="n">fm_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">,</span> <span class="n">path_times</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_t</span><span class="p">:</span>
            <span class="n">fm_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fm_paths</span><span class="p">,</span> <span class="n">min_t</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">id_wcc</span></div>


<div class="viewcode-block" id="compute_all_foremost_paths"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_all_foremost_paths">[docs]</a><span class="k">def</span> <span class="nf">compute_all_foremost_paths</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">duration_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute a foremost path between &#39;source&#39; and &#39;destination&quot; starting at &#39;begin time&#39;.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print(&quot;Foremost path from &quot;, source, &quot; to &quot;, destination, &quot; starting at time &quot;, start)</span>

    <span class="c1"># Get starting component</span>
    <span class="k">if</span> <span class="n">start_comp</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="n">start_comp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[[</span><span class="n">id_scc</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id_wcc</span>
                <span class="n">start_comp</span> <span class="o">=</span> <span class="n">id_scc</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not exist in the Stream Graph at time &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; !&quot;</span><span class="p">)</span>
    <span class="c1"># Iterate on link</span>
    <span class="c1"># Construct adjacency list (directed)</span>

    <span class="c1"># TODO : We shouldn&#39;t have to construct &#39;a_l&#39;, the adjacency list, every time. Maybe as an attribute of G ?</span>
    <span class="n">a_l</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">end_time_comp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
            <span class="c1"># ONLY IF the destination is accesible from begin time</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">a_l</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">end_time_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">duration_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">end_time_comp</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">duration_threshold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_time_comp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span>

    <span class="c1"># print(&quot;duration threshold :&quot;,duration_threshold)</span>
    <span class="c1"># print(&quot; a_l : &quot;, a_l)</span>

    <span class="c1"># Custom BFS on DAG</span>
    <span class="k">def</span> <span class="nf">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="n">path_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start_comp</span><span class="p">,</span> <span class="p">[</span><span class="n">start_comp</span><span class="p">])]</span>
        <span class="n">foremost_duration</span> <span class="o">=</span> <span class="n">duration_threshold</span>  <span class="c1"># This variable, once assigned, is used as a threshold (yeah)</span>
        <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
            <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># print(&quot; v : &quot;,v)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; len path queue :&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; comp id :&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; comp times :&quot;</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="c1"># print(&quot;PATH Found :&quot;,path)</span>
                        <span class="n">foremost_duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">foremost_duration</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                        <span class="c1"># return path + [c]</span>
                    <span class="k">elif</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">foremost_duration</span><span class="p">:</span>
                        <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]))</span>

    <span class="c1"># print(&quot; Start BFS&quot;)</span>
    <span class="n">foremost_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">))</span>
    <span class="c1">#</span>
    <span class="c1"># foremost_path = bfs_scc(a_l, start_comp, destination)</span>
    <span class="c1"># if foremost_path:</span>
    <span class="c1">#     return [foremost_path],dict_id_wcc_to_dag[id_wcc].index_id_scc_to_nodes[foremost_path[-1]].times[0]-start,id_wcc</span>
    <span class="c1"># else:</span>
    <span class="c1">#     return None, None, None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">foremost_paths</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">path_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">foremost_paths</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">path_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="c1"># print(&quot;Path times :&quot;, path_times)</span>
    <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path_times</span><span class="p">])</span>
    <span class="c1"># print(&quot;Foremost time : &quot;, min_t)</span>
    <span class="n">fm_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">,</span> <span class="n">path_times</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_t</span><span class="p">:</span>
            <span class="n">fm_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fm_paths</span><span class="p">,</span> <span class="n">min_t</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">id_wcc</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="bfs_with_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.bfs_with_path">[docs]</a><span class="k">def</span> <span class="nf">bfs_with_path</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">duration_threshold</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    BFS giving the path</span>
<span class="sd">    :param a_l:</span>
<span class="sd">    :param id_wcc:</span>
<span class="sd">    :param start_comp:</span>
<span class="sd">    :param start_time:</span>
<span class="sd">    :param destination:</span>
<span class="sd">    :param duration_threshold:</span>
<span class="sd">    :param dict_id_wcc_to_dag:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">path_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start_comp</span><span class="p">,</span> <span class="p">[</span><span class="n">start_comp</span><span class="p">])]</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">foremost_duration</span> <span class="o">=</span> <span class="n">duration_threshold</span>  <span class="c1"># This variable, once assigned, is used as a threshold (yeah)</span>
    <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
        <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># print(&quot; v : &quot;,v)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; len path queue :&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="c1"># print(&quot;PATH Found :&quot;,path)</span>
                        <span class="n">foremost_duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">foremost_duration</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                        <span class="c1"># return path + [c]</span>
                    <span class="k">elif</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start_time</span> <span class="o">+</span> <span class="n">foremost_duration</span><span class="p">:</span>
                        <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_foremost_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_foremost_path">[docs]</a><span class="k">def</span> <span class="nf">compute_foremost_path</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">duration_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute a foremost path between &#39;source&#39; and &#39;destination&quot; starting at &#39;begin time&#39;.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print(&quot;Foremost path from &quot;, source, &quot; to &quot;, destination, &quot; starting at time &quot;, start)</span>

    <span class="c1"># Get starting component</span>
    <span class="k">if</span> <span class="n">start_comp</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="n">start_comp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[[</span><span class="n">id_scc</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id_wcc</span>
                <span class="n">start_comp</span> <span class="o">=</span> <span class="n">id_scc</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not exist in the Stream Graph at time &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; !&quot;</span><span class="p">)</span>
    <span class="c1"># Iterate on link</span>
    <span class="c1"># Construct adjacency list (directed)</span>

    <span class="c1"># TODO : We shouldn&#39;t have to construct &#39;a_l&#39;, the adjacency list, every time. Maybe as an attribute of G ?</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
    <span class="n">a_l</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">duration_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a_l</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># duration_threshold = max(end_time_comp) + 1 - start</span>
        <span class="n">duration_threshold</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>

    <span class="n">foremost_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">bfs_with_path</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">duration_threshold</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">))</span>

    <span class="c1">#</span>
    <span class="c1"># foremost_path = bfs_scc(a_l, start_comp, destination)</span>
    <span class="c1"># if foremost_path:</span>
    <span class="c1">#     return [foremost_path],dict_id_wcc_to_dag[id_wcc].index_id_scc_to_nodes[foremost_path[-1]].times[0]-start,id_wcc</span>
    <span class="c1"># else:</span>
    <span class="c1">#     return None, None, None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">foremost_paths</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">path_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">foremost_paths</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">path_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="c1"># print(&quot;Path times :&quot;, path_times)</span>
    <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path_times</span><span class="p">])</span>
    <span class="c1"># print(&quot;Foremost time : &quot;, min_t)</span>
    <span class="n">fm_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">,</span> <span class="n">path_times</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_t</span><span class="p">:</span>
            <span class="n">fm_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fm_paths</span><span class="p">,</span> <span class="n">min_t</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">id_wcc</span></div>


<div class="viewcode-block" id="compute_foremost_path_pw"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_foremost_path_pw">[docs]</a><span class="k">def</span> <span class="nf">compute_foremost_path_pw</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">duration_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    # TODO : TO FINISH</span>
<span class="sd">    Compute a foremost path between &#39;source&#39; and &#39;destination&quot; starting at &#39;begin time&#39;.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Foremost path Pairwise from &quot;</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="s2">&quot; starting at time &quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>

    <span class="c1"># Get starting component</span>
    <span class="k">if</span> <span class="n">start_comp</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="n">start_comp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
            <span class="c1"># TODO : We can load only if times[0]&lt;=start&lt;= times[1], presently we load it anyway</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">start_comp</span> <span class="o">=</span> <span class="n">id_scc</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not exist in the Stream Graph at time &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; !&quot;</span><span class="p">)</span>
    <span class="c1"># Iterate on link</span>
    <span class="c1"># Construct adjacency list (directed)</span>
    <span class="c1"># print(&quot;Id wcc :&quot;, id_wcc, &quot;Start Comp : &quot;, start_comp)</span>
    <span class="n">dag_links</span> <span class="o">=</span> <span class="n">load_dag_links</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">)</span>

    <span class="c1"># print(&quot;DAG links :&quot;, dag_links)</span>
    <span class="c1"># print(&quot; Construct Adjacency List&quot;)  # TODO : We shouldn&#39;t have to construct it every time.</span>
    <span class="n">a_l</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">end_time_comp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dag_links</span><span class="p">:</span>
        <span class="c1"># ONLY IF the destination is accesible from begin time</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">a_l</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">end_time_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">lil_matrix</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">c_start</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">c_start</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">W</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">duration_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">duration_threshold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_time_comp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span>

    <span class="c1"># print(&quot;duration threshold :&quot;,duration_threshold)</span>
    <span class="c1"># print(&quot; a_l : &quot;, a_l)</span>

    <span class="c1"># Custom BFS on DAG</span>
    <span class="k">def</span> <span class="nf">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="n">path_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start_comp</span><span class="p">,</span> <span class="p">[</span><span class="n">start_comp</span><span class="p">])]</span>
        <span class="n">foremost_duration</span> <span class="o">=</span> <span class="n">duration_threshold</span>  <span class="c1"># This variable, once assigned, is used as a threshold (yeah)</span>
        <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
            <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># print(&quot; v : &quot;,v)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
                    <span class="c1"># print(&quot; comp nodes :&quot;,comp.nodes)</span>
                    <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="n">foremost_duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">foremost_duration</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">foremost_duration</span><span class="p">:</span>
                        <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]))</span>

    <span class="c1"># print(&quot; Start BFS&quot;)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">foremost_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
        <span class="n">path_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">foremost_paths</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">path_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># print(&quot;Path times :&quot;, path_times)</span>
        <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path_times</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">W</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_t</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">W</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">s</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_t</span> <span class="o">-</span> <span class="n">start</span>
    <span class="c1"># if not foremost_paths:</span>
    <span class="c1">#     return None, None, None</span>
    <span class="k">return</span> <span class="n">W</span></div>
    <span class="c1"># fm_paths = []</span>
    <span class="c1"># for p, t in zip(foremost_paths, path_times):</span>
    <span class="c1">#     if t[-1] == min_t:</span>
    <span class="c1">#         fm_paths.append(p)</span>
    <span class="c1"># return fm_paths, min_t - start, id_wcc</span>


<div class="viewcode-block" id="compute_fastest_path_streaming"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_fastest_path_streaming">[docs]</a><span class="k">def</span> <span class="nf">compute_fastest_path_streaming</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                                   <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the fastest path between &#39;source&#39; and &#39;destination&#39;</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param destination:</span>
<span class="sd">    :param scc_storage:</span>
<span class="sd">    :param dict_offset:</span>
<span class="sd">    :param refactor:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#  1.GET Potential Starting Component ( pretty useless, get the first one is ok).</span>
    <span class="c1">#  2.1 THEN FOREMOST, Get TIME as reference, THEN start again from last comp we&#39;ve seen &#39;source&#39; in the path</span>
    <span class="c1">#  2.3 Otherwise get the next comp with &#39;source&#39;</span>
    <span class="c1">#    Mark every browsed comp containing &#39;source&#39;.</span>
    <span class="c1"># Return Path in The Dag and Duration</span>
    <span class="c1"># 1.</span>
    <span class="n">Unvisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">times_end_comp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="c1"># print(&quot;Instantaneous Fp (path, latency, id_wcc) :&quot;,[[id_scc]], 0, id_wcc)</span>
                <span class="k">yield</span> <span class="p">[[</span><span class="n">id_scc</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Unvisited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>
                <span class="n">times_end_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 2.</span>
    <span class="c1"># print(&quot;Comp to visit :&quot;, Unvisited)</span>

    <span class="c1">#  TODO : On charge tout le temps le même DAG, faut corriger ça !</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">Unvisited</span><span class="p">:</span>
        <span class="k">yield</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">latency</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">list_wcc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span> <span class="o">=</span> <span class="n">Unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># print(&quot;\nId WCC :&quot;, id_wcc, &quot; Id SCC :&quot;, id_scc)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span><span class="o">.</span><span class="n">times</span>
        <span class="n">foremost_paths</span><span class="p">,</span> <span class="n">time_to_reach</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_foremost_path_streaming</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span>
                                                                           <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">),</span> <span class="n">destination</span><span class="p">,</span>
                                                                           <span class="n">dict_offset</span><span class="o">=</span><span class="n">dict_offset</span><span class="p">,</span>
                                                                           <span class="n">duration_threshold</span><span class="o">=</span><span class="n">latency</span><span class="p">,</span>
                                                                           <span class="n">start_comp</span><span class="o">=</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>
        <span class="c1"># print(&quot;Foremost path :&quot;, foremost_paths)</span>
        <span class="c1"># print(&quot;Time to reach :&quot;, time_to_reach)</span>
        <span class="k">if</span> <span class="n">foremost_paths</span> <span class="ow">and</span> <span class="n">time_to_reach</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">latency</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="n">time_to_reach</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">time_to_reach</span><span class="p">,</span> <span class="n">latency</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">):</span>
                <span class="c1"># Start Iterating on foremost paths :</span>
                <span class="n">last_comp_with_source</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Unvisited</span><span class="p">:</span>
                        <span class="n">last_comp_with_source</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">Unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="c1"># Test if we have found Shortcuts :</span>
                <span class="k">if</span> <span class="n">last_comp_with_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># print(&quot; shortcut gain :&quot;, last_comp_with_source)</span>
                    <span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">last_comp_with_source</span><span class="p">:]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">new_tor</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">b</span>
                <span class="c1"># print(&quot;New Time to reach :&quot;, new_tor)</span>
                <span class="k">if</span> <span class="n">new_tor</span> <span class="o">&lt;</span> <span class="n">latency</span><span class="p">:</span>
                    <span class="n">latency</span> <span class="o">=</span> <span class="n">new_tor</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                    <span class="n">list_wcc</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
                    <span class="c1"># print(&quot;  NEW LATENCY :&quot;, new_tor)</span>
                    <span class="c1"># print(&quot;  Current Fastest Paths :&quot;, paths)</span>
                    <span class="c1"># print(&quot;  Nb fastest paths :&quot;, len(paths))</span>
                <span class="k">elif</span> <span class="n">new_tor</span> <span class="o">==</span> <span class="n">latency</span><span class="p">:</span>
                    <span class="n">list_wcc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_wcc</span><span class="p">)</span>
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="c1"># print(&quot;  New fastest path :&quot;, foremost_paths[j])</span>
                    <span class="c1"># print(&quot;  Nb new paths :&quot;, len(foremost_paths))</span>

    <span class="c1"># print(&quot;paths :&quot;,paths)</span>
    <span class="c1"># print(&quot;latency :&quot;,latency)</span>
    <span class="c1"># print(&quot;list_wcc :&quot;,list_wcc)</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">latency</span><span class="p">,</span> <span class="n">list_wcc</span><span class="p">)</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_fastest_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_fastest_path">[docs]</a><span class="k">def</span> <span class="nf">compute_fastest_path</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                         <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the fastest path between &#39;source&#39; and &#39;destination&#39;</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param destination:</span>
<span class="sd">    :param scc_storage:</span>
<span class="sd">    :param dict_offset:</span>
<span class="sd">    :param refactor:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#  1.GET Potential Starting Component ( pretty useless, get the first one is ok).</span>
    <span class="c1">#  2.1 THEN FOREMOST, Get TIME as reference, THEN start again from last comp we&#39;ve seen &#39;source&#39; in the path</span>
    <span class="c1">#  2.3 Otherwise get the next comp with &#39;source&#39;</span>
    <span class="c1">#    Mark every browsed comp containing &#39;source&#39;.</span>
    <span class="c1"># Return Path in The Dag and Duration</span>
    <span class="c1"># 1.</span>
    <span class="n">Unvisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">times_end_comp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
        <span class="c1"># c = load_scc_from_msgpack(id_wcc, id_scc, scc_path, dict_offset_scc)</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="c1"># print(&quot;Instantaneous Fp (path, latency, id_wcc) :&quot;,[[id_scc]], 0, id_wcc)</span>
                <span class="k">yield</span> <span class="p">[[</span><span class="n">id_scc</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Unvisited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>
                <span class="n">times_end_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 2.</span>
    <span class="c1"># print(&quot;Comp to visit :&quot;, Unvisited)</span>

    <span class="c1">#  TODO : On charge tout le temps le même DAG, faut corriger ça !</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">Unvisited</span><span class="p">:</span>
        <span class="k">yield</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">latency</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">list_wcc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span> <span class="o">=</span> <span class="n">Unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># print(&quot;\nId WCC :&quot;, id_wcc, &quot; Id SCC :&quot;, id_scc)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">times</span>
        <span class="n">foremost_paths</span><span class="p">,</span> <span class="n">time_to_reach</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_foremost_path</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span>
                                                                 <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">),</span> <span class="n">destination</span><span class="p">,</span>
                                                                 <span class="n">dict_offset</span><span class="o">=</span><span class="n">dict_offset</span><span class="p">,</span>
                                                                 <span class="n">duration_threshold</span><span class="o">=</span><span class="n">latency</span><span class="p">,</span>
                                                                 <span class="n">start_comp</span><span class="o">=</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>
        <span class="c1"># print(&quot;Foremost path :&quot;, foremost_paths)</span>
        <span class="c1"># print(&quot;Time to reach :&quot;, time_to_reach)</span>
        <span class="k">if</span> <span class="n">foremost_paths</span> <span class="ow">and</span> <span class="n">time_to_reach</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">latency</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="n">time_to_reach</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">time_to_reach</span><span class="p">,</span> <span class="n">latency</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">):</span>
                <span class="c1"># Start Iterating on foremost paths :</span>
                <span class="n">last_comp_with_source</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Unvisited</span><span class="p">:</span>
                        <span class="n">last_comp_with_source</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">Unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="c1"># Test if we have found Shortcuts :</span>
                <span class="k">if</span> <span class="n">last_comp_with_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># print(&quot; shortcut gain :&quot;, last_comp_with_source)</span>
                    <span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">last_comp_with_source</span><span class="p">:]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># e = load_scc_from_msgpack(id_wcc, foremost_paths[j][-1], scc_path, dict_offset_scc).times[0]</span>
                <span class="c1"># b = load_scc_from_msgpack(id_wcc, foremost_paths[j][0], scc_path, dict_offset_scc).times[1]</span>
                <span class="n">new_tor</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">b</span>
                <span class="c1"># print(&quot;New Time to reach :&quot;, new_tor)</span>
                <span class="k">if</span> <span class="n">new_tor</span> <span class="o">&lt;</span> <span class="n">latency</span><span class="p">:</span>
                    <span class="n">latency</span> <span class="o">=</span> <span class="n">new_tor</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                    <span class="n">list_wcc</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
                    <span class="c1"># print(&quot;  NEW LATENCY :&quot;, new_tor)</span>
                    <span class="c1"># print(&quot;  Current Fastest Paths :&quot;, paths)</span>
                    <span class="c1"># print(&quot;  Nb fastest paths :&quot;, len(paths))</span>
                <span class="k">elif</span> <span class="n">new_tor</span> <span class="o">==</span> <span class="n">latency</span><span class="p">:</span>
                    <span class="n">list_wcc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_wcc</span><span class="p">)</span>
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="c1"># print(&quot;  New fastest path :&quot;, foremost_paths[j])</span>
                    <span class="c1"># print(&quot;  Nb new paths :&quot;, len(foremost_paths))</span>

    <span class="c1"># print(&quot;paths :&quot;,paths)</span>
    <span class="c1"># print(&quot;latency :&quot;,latency)</span>
    <span class="c1"># print(&quot;list_wcc :&quot;,list_wcc)</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">latency</span><span class="p">,</span> <span class="n">list_wcc</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_all_fastest_paths"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_all_fastest_paths">[docs]</a><span class="k">def</span> <span class="nf">compute_all_fastest_paths</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                              <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the fastest path between &#39;source&#39; and &#39;destination&#39;</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param destination:</span>
<span class="sd">    :param scc_storage:</span>
<span class="sd">    :param dict_offset:</span>
<span class="sd">    :param refactor:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#  1.GET Potential Starting Component ( pretty useless, get the first one is ok).</span>
    <span class="c1">#  2.1 THEN FOREMOST, Get TIME as reference, THEN start again from last comp we&#39;ve seen &#39;source&#39; in the path</span>
    <span class="c1">#  2.3 Otherwise get the next comp with &#39;source&#39;</span>
    <span class="c1">#    Mark every browsed comp containing &#39;source&#39;.</span>
    <span class="c1"># Return Path in The Dag and Duration</span>
    <span class="c1"># 1.</span>
    <span class="n">Unvisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">times_end_comp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
        <span class="c1"># c = load_scc_from_msgpack(id_wcc, id_scc, scc_path, dict_offset_scc)</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="c1"># print(&quot;Instantaneous Fp (path, latency, id_wcc) :&quot;,[[id_scc]], 0, id_wcc)</span>
                <span class="k">yield</span> <span class="p">[[</span><span class="n">id_scc</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Unvisited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>
                <span class="n">times_end_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 2.</span>
    <span class="c1"># print(&quot;Comp to visit :&quot;, Unvisited)</span>

    <span class="c1">#  TODO : On charge tout le temps le même DAG, faut corriger ça !</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">Unvisited</span><span class="p">:</span>
        <span class="k">yield</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">latency</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">list_wcc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span> <span class="o">=</span> <span class="n">Unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># print(&quot;\nId WCC :&quot;, id_wcc, &quot; Id SCC :&quot;, id_scc)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">times</span>
        <span class="n">foremost_paths</span><span class="p">,</span> <span class="n">time_to_reach</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_all_foremost_paths</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span>
                                                                      <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">),</span> <span class="n">destination</span><span class="p">,</span>
                                                                      <span class="n">dict_offset</span><span class="o">=</span><span class="n">dict_offset</span><span class="p">,</span>
                                                                      <span class="n">duration_threshold</span><span class="o">=</span><span class="n">latency</span><span class="p">,</span>
                                                                      <span class="n">start_comp</span><span class="o">=</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>
        <span class="c1"># print(&quot;Foremost path :&quot;, foremost_paths)</span>
        <span class="c1"># print(&quot;Time to reach :&quot;, time_to_reach)</span>
        <span class="k">if</span> <span class="n">foremost_paths</span> <span class="ow">and</span> <span class="n">time_to_reach</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">latency</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="n">time_to_reach</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">time_to_reach</span><span class="p">,</span> <span class="n">latency</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">):</span>
                <span class="c1"># Start Iterating on foremost paths :</span>
                <span class="n">last_comp_with_source</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Unvisited</span><span class="p">:</span>
                        <span class="n">last_comp_with_source</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">Unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="c1"># Test if we have found Shortcuts :</span>
                <span class="k">if</span> <span class="n">last_comp_with_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># print(&quot; shortcut gain :&quot;, last_comp_with_source)</span>
                    <span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">last_comp_with_source</span><span class="p">:]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># e = load_scc_from_msgpack(id_wcc, foremost_paths[j][-1], scc_path, dict_offset_scc).times[0]</span>
                <span class="c1"># b = load_scc_from_msgpack(id_wcc, foremost_paths[j][0], scc_path, dict_offset_scc).times[1]</span>
                <span class="n">new_tor</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">b</span>
                <span class="c1"># print(&quot;New Time to reach :&quot;, new_tor)</span>
                <span class="k">if</span> <span class="n">new_tor</span> <span class="o">&lt;</span> <span class="n">latency</span><span class="p">:</span>
                    <span class="n">latency</span> <span class="o">=</span> <span class="n">new_tor</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                    <span class="n">list_wcc</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
                    <span class="c1"># print(&quot;  NEW LATENCY :&quot;, new_tor)</span>
                    <span class="c1"># print(&quot;  Current Fastest Paths :&quot;, paths)</span>
                    <span class="c1"># print(&quot;  Nb fastest paths :&quot;, len(paths))</span>
                <span class="k">elif</span> <span class="n">new_tor</span> <span class="o">==</span> <span class="n">latency</span><span class="p">:</span>
                    <span class="n">list_wcc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_wcc</span><span class="p">)</span>
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="c1"># print(&quot;  New fastest path :&quot;, foremost_paths[j])</span>
                    <span class="c1"># print(&quot;  Nb new paths :&quot;, len(foremost_paths))</span>

    <span class="c1"># print(&quot;paths :&quot;,paths)</span>
    <span class="c1"># print(&quot;latency :&quot;,latency)</span>
    <span class="c1"># print(&quot;list_wcc :&quot;,list_wcc)</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">latency</span><span class="p">,</span> <span class="n">list_wcc</span><span class="p">)</span></div>


<span class="c1">###########################################</span>
<span class="c1">#       Latency Functions                 #</span>
<span class="c1">###########################################</span>

<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="bfs_with_ttr"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.bfs_with_ttr">[docs]</a><span class="k">def</span> <span class="nf">bfs_with_ttr</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                 <span class="n">duration_threshold</span><span class="p">,</span> <span class="n">unvisited</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    BFS giving the time to reach</span>
<span class="sd">    :param a_l:</span>
<span class="sd">    :param id_wcc:</span>
<span class="sd">    :param start_comp:</span>
<span class="sd">    :param start_time:</span>
<span class="sd">    :param destination:</span>
<span class="sd">    :param duration_threshold:</span>
<span class="sd">    :param dict_id_wcc_to_dag:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># SortedList doesn&#39;t work</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">start_comp</span><span class="p">,</span> <span class="n">start_time</span><span class="p">)])</span>  <span class="c1"># source time corresponds to the last comp.times[0] containing the source</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_comp</span><span class="p">])</span>
    <span class="n">ttr</span> <span class="o">=</span> <span class="n">duration_threshold</span>  <span class="c1"># This variable, once assigned, is used as a threshold (yeah)</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unvisited</span><span class="p">:</span>
                <span class="n">unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">((</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">ttr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttr</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">ttr</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">st</span> <span class="o">+</span> <span class="n">ttr</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">st</span><span class="p">))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_ttr"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_ttr">[docs]</a><span class="k">def</span> <span class="nf">compute_ttr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                <span class="n">duration_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unvisited</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute time to reach a temporal destination node from a temporal source node and starting at &#39;begin time&#39;.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Get starting component</span>
    <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># IMPORTANT si &#39;start_comp&#39; pas spécifié NE PAS SUPPRIMER</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>
                <span class="n">start_comp</span> <span class="o">=</span> <span class="n">id_scc</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not exist in the Stream Graph at time &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; !&quot;</span><span class="p">)</span>
    <span class="n">a_l</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">duration_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a_l</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># duration_threshold = max(end_time_comp) + 1 - start</span>
        <span class="n">duration_threshold</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>

    <span class="n">ttr_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">bfs_with_ttr</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                     <span class="n">duration_threshold</span><span class="p">,</span> <span class="n">unvisited</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ttr_list</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttr_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_latency"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_latency">[docs]</a><span class="k">def</span> <span class="nf">compute_latency</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the latency path between &#39;source&#39; and &#39;destination&#39;</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param destination:</span>
<span class="sd">    :param scc_storage:</span>
<span class="sd">    :param refactor:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#  1.GET Potential Starting Component ( pretty useless, get the first one is ok).</span>
    <span class="c1">#  2.1 THEN FOREMOST, Get TIME as reference, THEN start again from last comp we&#39;ve seen &#39;source&#39; in the path</span>
    <span class="c1">#  2.3 Otherwise get the next comp with &#39;source&#39;</span>
    <span class="c1">#    Mark every browsed comp containing &#39;source&#39;.</span>
    <span class="c1"># Return Path in The Dag and Duration</span>
    <span class="c1"># 1.</span>
    <span class="n">Unvisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">latency</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Unvisited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">Unvisited</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">latency</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span> <span class="o">=</span> <span class="n">Unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">time_to_reach</span> <span class="o">=</span> <span class="n">compute_ttr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span>
                                    <span class="n">st</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                                    <span class="n">duration_threshold</span><span class="o">=</span><span class="n">latency</span><span class="p">,</span>
                                    <span class="n">start_comp</span><span class="o">=</span><span class="n">id_scc</span><span class="p">,</span>
                                    <span class="n">unvisited</span><span class="o">=</span><span class="n">Unvisited</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_to_reach</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">latency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="n">time_to_reach</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">time_to_reach</span><span class="p">,</span> <span class="n">latency</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">latency</span></div>


<div class="viewcode-block" id="compute_latency_ss"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_latency_ss">[docs]</a><span class="k">def</span> <span class="nf">compute_latency_ss</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    # TODO : tester une version où on a Unvisited_wcc et Unvisited_scc</span>
<span class="sd">    Compute latencies from *source* to every nodes of S</span>
<span class="sd">    :param dict_id_wcc_dag:</span>
<span class="sd">    :param index_node_to_scc:</span>
<span class="sd">    :param source:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># clefs : destination nodes ; valeurs : ttr</span>
    <span class="n">Unvisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>  <span class="c1"># On itere sur les scc contenant source</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">L</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">Unvisited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">))</span>  <span class="c1"># on récupère les dag contenant la source</span>

    <span class="n">dict_comp_to_ttr</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># clefs : (id_wcc,id_scc), values : ttr ssc from source</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="o">=</span> <span class="n">Unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="c1"># G.plot_custom(arrow=True)</span>
        <span class="c1"># plt.show()</span>
        <span class="n">dict_comp_to_ttr</span> <span class="o">=</span> <span class="n">compute_ttr_ss</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">dict_comp_to_ttr</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="n">id_scc</span><span class="p">,</span> <span class="n">unvisited</span><span class="o">=</span><span class="n">Unvisited</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">unpack_ttr</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">dict_comp_to_ttr</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span></div>


<div class="viewcode-block" id="compute_ttr_ss"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.compute_ttr_ss">[docs]</a><span class="k">def</span> <span class="nf">compute_ttr_ss</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">dict_comp_to_ttr</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">unvisited</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute time to reach every nodes in a WCC from a source</span>
<span class="sd">    %Techniquement dans chaque DAG la racine est la comp id_scc = 0</span>
<span class="sd">    :param G:</span>
<span class="sd">    :param id_wcc:</span>
<span class="sd">    :param dict_comp_to_ttr:</span>
<span class="sd">    :param source:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">a_l</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
    <span class="n">st</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># leaving time</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">start_comp</span><span class="p">,</span> <span class="n">st</span><span class="p">)])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_comp</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unvisited</span><span class="p">:</span>
                <span class="n">unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">((</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">dict_comp_to_ttr</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">st</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dict_comp_to_ttr</span><span class="p">:</span>
                    <span class="n">dict_comp_to_ttr</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dict_comp_to_ttr</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">v</span><span class="p">)],</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dict_comp_to_ttr</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">st</span><span class="p">))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dict_comp_to_ttr</span></div>


<div class="viewcode-block" id="unpack_ttr"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.unpack_ttr">[docs]</a><span class="k">def</span> <span class="nf">unpack_ttr</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">dict_comp_to_ttr</span><span class="p">,</span> <span class="n">done</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">ttr</span> <span class="o">=</span> <span class="p">[</span><span class="n">dict_comp_to_ttr</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dict_comp_to_ttr</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ttr</span><span class="p">:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span></div>


<span class="c1"># A priori : faire un Floyd Warshall sur le condensation DAG :</span>
<span class="c1"># - Tous les noeuds dans la meme comp C0=(I0,X0): W[u \in X0, v\in X0] = 0</span>
<span class="c1"># - W[u \in X_i, v \in X_j] =  min(W[u \in X_i, v \in X_j],W[u \in X_i, k \in X_h]+W[k \in X_h, v \in X_j])</span>
<span class="c1"># def compute_latency_pw(dict_id_wcc_dag, index_node_to_scc):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     Compute all latencies in S</span>
<span class="c1">#     :param dict_id_wcc_dag:</span>
<span class="c1">#     :param index_node_to_scc:</span>
<span class="c1">#     :return:</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     W = lil_matrix((max(index_node_to_scc) + 1, max(index_node_to_scc) + 1))</span>
<span class="c1">#</span>
<span class="c1">#     return W</span>
<span class="c1">###########################################</span>
<span class="c1">#       Fuzzing Functions (TEST)          #</span>
<span class="c1">###########################################</span>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="fuzz_fastest_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.fuzz_fastest_path">[docs]</a><span class="k">def</span> <span class="nf">fuzz_fastest_path</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span>
                      <span class="n">dict_offset_scc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">dict_id_wcc_to_dag</span> <span class="o">=</span> <span class="n">load_condensation_dags</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">compute_fastest_path</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">,</span>
                                              <span class="n">index_node_to_scc</span><span class="p">,</span>
                                              <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="n">dict_offset_scc</span><span class="p">))</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nb_of_paths</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">R</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fastest Path from &quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s2">&quot; to &quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="s2">&quot; (latency = &quot;</span><span class="p">,</span> <span class="n">latency</span><span class="p">,</span>
                      <span class="s2">&quot;, nb of paths =&quot;</span><span class="p">,</span> <span class="n">nb_of_paths</span><span class="p">,</span> <span class="s2">&quot;): &quot;</span><span class="p">)</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="fuzz_latency"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.fuzz_latency">[docs]</a><span class="k">def</span> <span class="nf">fuzz_latency</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span>
                 <span class="n">dict_offset_scc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">high_degree_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">dict_id_wcc_to_dag</span> <span class="o">=</span> <span class="n">load_condensation_dags</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Condensation Streams Loaded in &quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span><span class="p">,</span> <span class="s2">&quot;s ! Begin fuzzing :)&quot;</span><span class="p">)</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">random_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">high_degree_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># DEGREE LIKE DESCRIBE IN FORMALISM</span>
        <span class="c1"># d = S.degrees()</span>
        <span class="c1"># nodes = [k for k,v in sorted(d.items(),reverse=True, key = lambda x:x[1])][0:30] #tenth highest degree nodes</span>
        <span class="c1"># print([(k,v) for k, v in sorted(d.items(), reverse=True, key=lambda x: x[1])][0:30])</span>
        <span class="c1"># CLASSICAL DEGREE NOTION</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">degrees_partition</span><span class="p">()</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">degree</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">S</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
    <span class="n">nb_paths_to_compute</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of paths to compute :&quot;</span><span class="p">,</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="n">cnt_null_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_non_null_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_none_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">latency</span> <span class="o">=</span> <span class="n">compute_latency</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">,</span>
                                          <span class="n">index_node_to_scc</span>
                                          <span class="p">)</span>
                <span class="k">if</span> <span class="n">latency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cnt_none_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">latency</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cnt_null_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt_non_null_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Latency from &quot;, u, &quot; to &quot;, v, &quot; :&quot;, latency)</span>
    <span class="n">time_end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Paths latencies computed in &quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time per latency :&quot;</span><span class="p">,</span> <span class="n">time_end</span> <span class="o">/</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_none_latencies</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Null latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_null_latencies</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strictly Positive latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_non_null_latencies</span><span class="p">)</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="fuzz_latency_ss"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.fuzz_latency_ss">[docs]</a><span class="k">def</span> <span class="nf">fuzz_latency_ss</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span>
                    <span class="n">dict_offset_scc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">high_degree_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">dict_id_wcc_to_dag</span> <span class="o">=</span> <span class="n">load_condensation_dags</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Condensation Streams Loaded in &quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span><span class="p">,</span> <span class="s2">&quot;s ! Begin fuzzing :)&quot;</span><span class="p">)</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">random_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">high_degree_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># DEGREE LIKE DESCRIBE IN FORMALISM</span>
        <span class="c1"># d = S.degrees()</span>
        <span class="c1"># nodes = [k for k,v in sorted(d.items(),reverse=True, key = lambda x:x[1])][0:30] #tenth highest degree nodes</span>
        <span class="c1"># print([(k,v) for k, v in sorted(d.items(), reverse=True, key=lambda x: x[1])][0:30])</span>
        <span class="c1"># CLASSICAL DEGREE NOTION</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">degrees_partition</span><span class="p">()</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">degree</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">S</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
    <span class="n">nb_paths_to_compute</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of paths to compute :&quot;</span><span class="p">,</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="n">cnt_null_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_non_null_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_none_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">compute_latency_ss</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">u</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
                    <span class="n">cnt_none_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;No paths between &quot;, u, &quot; and &quot;, v, &quot; !&quot;)</span>
                <span class="k">elif</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cnt_null_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Latency from &quot;, u, &quot; to &quot;, v, &quot; :&quot;, L[v])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt_non_null_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Latency from &quot;, u, &quot; to &quot;, v, &quot; :&quot;, L[v])</span>
    <span class="n">time_end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Paths latencies computed in &quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time per latency :&quot;</span><span class="p">,</span> <span class="n">time_end</span> <span class="o">/</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_none_latencies</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Null latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_null_latencies</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strictly Positive latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_non_null_latencies</span><span class="p">)</span></div>


<div class="viewcode-block" id="fuzz_latencies_wu"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.fastest_path_algorithm.fuzz_latencies_wu">[docs]</a><span class="k">def</span> <span class="nf">fuzz_latencies_wu</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">dict_offset_wcc</span><span class="p">,</span> <span class="n">dag_path</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">,</span> <span class="n">random_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">high_degree_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">dict_id_wcc_to_dag</span> <span class="o">=</span> <span class="n">load_condensation_dags</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="n">dict_offset_scc</span><span class="p">,</span> <span class="n">dict_offset_dag</span><span class="p">,</span> <span class="n">scc_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">random_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">high_degree_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># DEGREE LIKE DESCRIBE IN FORMALISM</span>
        <span class="c1"># d = S.degrees()</span>
        <span class="c1"># nodes = [k for k,v in sorted(d.items(),reverse=True, key = lambda x:x[1])][0:10] #tenth highest degree nodes</span>
        <span class="c1"># print([(k,v) for k, v in sorted(d.items(), reverse=True, key=lambda x: x[1])][0:10])</span>
        <span class="c1"># CLASSICAL DEGREE NOTION</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">degrees_partition</span><span class="p">()</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">degree</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">S</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
    <span class="n">nb_paths_to_compute</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of paths to compute :&quot;</span><span class="p">,</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="n">cnt_null_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_non_null_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_none_latencies</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">########</span>
    <span class="n">id_wcc_to_augmented_neighborhood</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">id_wcc_to_node_presence</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">id_wcc_to_links</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">list_id_wcc</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">index_node_to_wcc</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">list_id_wcc</span><span class="p">:</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">load_wcc</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dict_offset_wcc</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">)</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">compute_augmented_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="o">=</span><span class="n">node_presence</span><span class="p">)</span>
        <span class="n">id_wcc_to_node_presence</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_presence</span>
        <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">id_wcc_to_links</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">links</span>
    <span class="c1">#######</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">compute_latency_ss</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">)</span>
        <span class="c1"># L = compute_latencies_wu(u, index_node_to_wcc,</span>
        <span class="c1">#                          id_wcc_to_augmented_neighborhood,</span>
        <span class="c1">#                          id_wcc_to_node_presence)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">u</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
                    <span class="n">cnt_none_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;No paths between &quot;, u, &quot; and &quot;, v, &quot; !&quot;)</span>
                <span class="k">elif</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># assert L[v] == L2[v]</span>
                    <span class="n">cnt_null_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Latency from &quot;, u, &quot; to &quot;, v, &quot; :&quot;, L[v])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># assert L[v] == L2[v]</span>
                    <span class="n">cnt_non_null_latencies</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Latency from &quot;, u, &quot; to &quot;, v, &quot; :&quot;, L[v])</span>
    <span class="n">time_end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Paths latencies computed in &quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time per latency :&quot;</span><span class="p">,</span> <span class="n">time_end</span> <span class="o">/</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_none_latencies</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Null latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_null_latencies</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strictly Positive latencies :&quot;</span><span class="p">,</span> <span class="n">cnt_non_null_latencies</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">straph.analysis</span> <span class="k">import</span> <span class="n">visualisation_stream_graph_properties</span> <span class="k">as</span> <span class="n">viz</span>
<span class="kn">from</span> <span class="nn">straph.utils</span> <span class="k">import</span> <span class="n">profile_shit</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/Crawdad/Infocom/&quot;</span>
    <span class="n">__filedate__</span> <span class="o">=</span> <span class="s2">&quot;infocom&quot;</span>

    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/Crawdad/Rollernet/&quot;</span>
    <span class="n">__filedate__</span> <span class="o">=</span> <span class="s2">&quot;rollernet&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/&quot;</span>
    <span class="c1"># __filedate__ = &quot;sg_generated&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/example_paper/&quot;</span>
    <span class="c1"># __file__ = &quot;example_paper&quot;</span>
    <span class="c1">#</span>
    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/Socio_Patterns/High_School_2013/&quot;</span>
    <span class="vm">__file__</span> <span class="o">=</span> <span class="s2">&quot;High_School_2013&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/slashdot/&quot;</span>
    <span class="c1"># __file__ = &quot;slashdot-threads&quot;</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/path_examples/&quot;</span>
    <span class="c1"># __file__ = &quot;path_example&quot;</span>

    <span class="n">wcc_storage_path</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_wcc_storage/wcc.scf&quot;</span>
    <span class="n">scc_storage_path</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_scc_storage/scc.scf&quot;</span>
    <span class="n">dag_storage_path</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_scc_dag_storage/scc_dag_with_links.scf&quot;</span>

    <span class="n">dict_offset_dag_storage_path</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_scc_dag_storage/dict_offset_dag.mpck&quot;</span>
    <span class="n">dict_offset_dag</span> <span class="o">=</span> <span class="n">compute_dict_offset_dag</span><span class="p">(</span><span class="n">dag_storage_path</span><span class="p">,</span> <span class="n">dict_offset_dag_storage_path</span><span class="p">)</span>
    <span class="n">dict_offset_dag</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">dict_offset_dag_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">),</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">dict_offset_scc_storage_path</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_scc_dag_storage/dict_offset_scc.mpck&quot;</span>
    <span class="n">dict_offset_scc</span> <span class="o">=</span> <span class="n">compute_dict_offset_scc</span><span class="p">(</span><span class="n">scc_storage_path</span><span class="p">,</span> <span class="n">dict_offset_scc_storage_path</span><span class="p">)</span>
    <span class="n">dict_offset_scc</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">dict_offset_scc_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">),</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">index_node_to_wcc</span> <span class="o">=</span> <span class="n">construct_index_node_to_wcc</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">)</span>
    <span class="n">dict_offset_wcc</span> <span class="o">=</span> <span class="n">compute_dict_offset_wcc</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">)</span>

    <span class="n">index_node_to_scc</span> <span class="o">=</span> <span class="n">construct_index_node_to_scc</span><span class="p">(</span><span class="n">scc_storage_path</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">read_stream_graph_from_sgf</span><span class="p">(</span><span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_ordered_links.sgf&quot;</span><span class="p">)</span>

    <span class="c1"># test_latency(dag_storage_path,scc_storage_path,index_node_to_scc,dict_offset_scc,dict_offset_dag)</span>

    <span class="c1"># S.plot()</span>
    <span class="c1"># plt.show()</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Foremost PATH                    #</span>
    <span class="c1">######################################</span>
    <span class="c1"># source = (0, 0)</span>
    <span class="c1"># destination = 4</span>
    <span class="c1"># foremost_path, ttr, id_wcc = compute_foremost_path_streaming(dag_storage_path, scc_storage_path,</span>
    <span class="c1">#                                                    index_node_to_scc, source,</span>
    <span class="c1">#                                                    destination, dict_offset_scc=dict_offset_scc)</span>
    <span class="c1"># print(&quot;Foremost Path from &quot;, source, &quot; to &quot;, destination, &quot; (time to reach = &quot;, ttr, &quot;): &quot;)</span>
    <span class="c1"># print(foremost_path)</span>
    <span class="c1"># for p in foremost_path:</span>
    <span class="c1">#     plot_foremost_path(p, ttr, id_wcc, S, source, destination)</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Fastest PATH                     #</span>
    <span class="c1">######################################</span>
    <span class="c1"># source = 1</span>
    <span class="c1"># destination = 5</span>
    <span class="c1"># R = list(compute_fastest_path_streaming(dag_storage_path, scc_storage_path,</span>
    <span class="c1">#                                                        index_node_to_scc,</span>
    <span class="c1">#                                                        source, destination, dict_offset_scc=dict_offset_scc))</span>
    <span class="c1"># print(&quot;R :&quot;,R)</span>
    <span class="c1"># latency = R[0][1]</span>
    <span class="c1"># print(&quot;Fastest Path from &quot;, source, &quot; to &quot;, destination, &quot; (latency = &quot;, latency, &quot;): &quot;)</span>
    <span class="c1"># for r in R:</span>
    <span class="c1">#     if r[0] is not None:</span>
    <span class="c1">#         fastest_paths = r[0]</span>
    <span class="c1">#         list_wcc = r[2]</span>
    <span class="c1">#         for p,id_wcc in zip(fastest_paths,list_wcc):</span>
    <span class="c1">#             print(&quot;p :&quot;,p)</span>
    <span class="c1">#             plot_fastest_path(p, latency, id_wcc, S, source, destination)</span>
    <span class="c1"># plt.show()</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Fastest PATH FUZZING             #</span>
    <span class="c1">######################################</span>

    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_latency(S,dag_storage_path,scc_storage_path,index_node_to_scc,dict_offset_scc,dict_offset_dag)&quot;,</span>
    <span class="c1">#              snakeviz=True)</span>
    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_latency(S,dag_storage_path,scc_storage_path,index_node_to_scc,dict_offset_scc,dict_offset_dag,&quot;</span>
    <span class="c1">#              &quot;random_nodes=True)&quot;, snakeviz=True)</span>
    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_latency(S,dag_storage_path,scc_storage_path,index_node_to_scc,dict_offset_scc,dict_offset_dag,&quot;</span>
    <span class="c1">#              &quot;high_degree_nodes=True)&quot;,snakeviz=True)</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Fastest PATH SS FUZZING          #</span>
    <span class="c1">######################################</span>
    <span class="c1"># fuzz_latency_ss(S, dag_storage_path, scc_storage_path, index_node_to_scc, dict_offset_scc, dict_offset_dag)#,high_degree_nodes=True)</span>
    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_latency_ss(S,dag_storage_path,scc_storage_path,index_node_to_scc,dict_offset_scc,dict_offset_dag)&quot;,</span>
    <span class="c1">#              snakeviz=True)</span>
    <span class="n">profile_shit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                 <span class="s2">&quot;fuzz_latency_ss(S,dag_storage_path,scc_storage_path,index_node_to_scc,dict_offset_scc,dict_offset_dag,&quot;</span>
                 <span class="s2">&quot;high_degree_nodes=True)&quot;</span><span class="p">,</span> <span class="n">snakeviz</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_latencies_wu(S, wcc_storage_path, index_node_to_wcc,dict_offset_wcc,dag_storage_path,&quot;</span>
    <span class="c1">#              &quot;scc_storage_path,high_degree_nodes=True)&quot;,</span>
    <span class="c1">#              snakeviz=True)</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Foremost PATH Single Source      #</span>
    <span class="c1">######################################</span>
    <span class="c1"># source = (225, 4)</span>
    <span class="c1"># W = compute_foremost_path_pw(dag_storage_path, scc_storage_path,</span>
    <span class="c1">#                                                    index_node_to_scc, source, dict_offset_scc=dict_offset_scc)</span>
    <span class="c1"># values = []</span>
    <span class="c1"># for i in range(W.shape[0]):</span>
    <span class="c1">#     for j in range(W.shape[1]):</span>
    <span class="c1">#         if W[i, j] != 0:</span>
    <span class="c1">#             values.append(W[i, j])</span>
    <span class="c1"># print(&quot;W :&quot;,W)</span>
    <span class="c1"># print(&quot;Mean :&quot;, sum(values) / len(values))</span>
    <span class="c1"># print(&quot;Max :&quot;, max(values))</span>
    <span class="c1"># plt.show()</span>
    <span class="c1">######################################</span>
    <span class="c1">#   Fastest  PATH Single Source      #</span>
    <span class="c1">######################################</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Foremost PATH PairWise           #</span>
    <span class="c1">######################################</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Fastest PATH PairWise            #</span>
    <span class="c1">######################################</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2019, Eol Ournan.
      Last updated on Oct 22, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>