

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>straph.streaming_algorithms.shortest_path_streaming &mdash; straph 1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> straph
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">straph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>straph.streaming_algorithms.shortest_path_streaming</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for straph.streaming_algorithms.shortest_path_streaming</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">jit</span>

<span class="kn">import</span> <span class="nn">pathlib</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">msgpack</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatch</span>

<span class="kn">from</span> <span class="nn">sortedcollections</span> <span class="k">import</span> <span class="n">ValueSortedDict</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="k">import</span> <span class="n">SortedSet</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="k">import</span> <span class="n">SortedSet</span><span class="p">,</span> <span class="n">SortedList</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">lil_matrix</span>

<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">stream</span> <span class="k">as</span> <span class="n">sg</span>
<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">components</span> <span class="k">as</span> <span class="n">wcc</span>
<span class="kn">from</span> <span class="nn">straph.utils</span> <span class="k">import</span> <span class="n">profile_shit</span>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_neighborhood"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_neighborhood">[docs]</a><span class="k">def</span> <span class="nf">compute_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">):</span>
    <span class="c1"># See &#39;neighborhood_with_node_presence&#39; in stream.py</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="c1"># print(&quot; l :&quot;,l)</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">N</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">N</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">N</span></div>


<div class="viewcode-block" id="compute_dict_offset_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_dict_offset_wcc">[docs]</a><span class="k">def</span> <span class="nf">compute_dict_offset_wcc</span><span class="p">(</span><span class="n">path_wcc_scf</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute offset of each dag in &#39;scc_dag.scf&#39;, in order to fast access a dag.</span>
<span class="sd">    :param path_scc_scf:</span>
<span class="sd">    :param storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">id_wcc_2_offset</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_wcc_scf</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">id_wcc_2_offset</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">storage_path</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">msgpack</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">id_wcc_2_offset</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">id_wcc_2_offset</span></div>


<span class="c1">#</span>
<span class="c1"># def wcc_shortest_path(links,alpha,omega,source):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     Single Source Algorithm</span>
<span class="c1">#     :param links:</span>
<span class="c1">#     :param alpha:</span>
<span class="c1">#     :param omega:</span>
<span class="c1">#     :param source:</span>
<span class="c1">#     :return:</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     # Compute Neighborhood :</span>
<span class="c1">#     N = compute_neighborhood(links)</span>
<span class="c1">#     nodes = set(N.keys())</span>
<span class="c1">#     # print(&quot; Neighborhood : &quot;, N)</span>
<span class="c1">#     S = set()  # Visited Nodes</span>
<span class="c1">#     L = set()  # Visited Links</span>
<span class="c1">#     d = {n: math.inf for n in nodes} # Distance from source</span>
<span class="c1">#     d[source] = 0</span>
<span class="c1">#     p = {}  # Previous node</span>
<span class="c1">#     a = defaultdict(lambda: alpha)  # Minimal time of arrival from previous node</span>
<span class="c1">#     l = defaultdict(lambda: omega)  # Maximal time of departure from this node</span>
<span class="c1">#     while S != nodes:</span>
<span class="c1">#         v = min(set(d.keys()) - S, key=d.get)</span>
<span class="c1">#         # print(&quot; current node v : &quot;,v)</span>
<span class="c1">#         # print(&quot; a[v] :&quot;,a[v],&quot; l[v] :&quot;,l[v])</span>
<span class="c1">#         for (t0, t1, w) in sorted(N[v] - L,key=lambda x:x[0]):</span>
<span class="c1">#             # print(&quot; \tcurrent neighbor w: &quot;,(t0,t1,w))</span>
<span class="c1">#             # print(&quot; \ta[w] :&quot;,a[w])</span>
<span class="c1">#             if a[v]&lt;=t1 :  # If the link is already over, we cannot take it (noshitsherlock)!</span>
<span class="c1">#                 new_path = d[v] + 1</span>
<span class="c1">#                 if new_path &lt; d[w]:</span>
<span class="c1">#                     d[w] = new_path</span>
<span class="c1">#                     p[w] = v</span>
<span class="c1">#                     a[w] = max(a[v],t0) # We can have an arrival already ahead of a link&#39;s beginning</span>
<span class="c1">#                     l[w] = t1</span>
<span class="c1">#                 elif new_path == d[w] and t0 &lt; a[w]:</span>
<span class="c1">#                     p[w] = v</span>
<span class="c1">#                     a[w] = max(a[v],t0)</span>
<span class="c1">#                     l[w] = t1</span>
<span class="c1">#         S.add(v)</span>
<span class="c1">#         L |= set([el for el in N[v]])</span>
<span class="c1">#     # print(&quot; a : &quot;,a)</span>
<span class="c1">#     # print(&quot; l : &quot;,l)</span>
<span class="c1">#     # print(&quot; d : &quot;,d)</span>
<span class="c1">#     # print(&quot; p : &quot;,p)</span>
<span class="c1">#     return p,d,a,l</span>


<div class="viewcode-block" id="wcc_shortest_path_pw"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.wcc_shortest_path_pw">[docs]</a><span class="k">def</span> <span class="nf">wcc_shortest_path_pw</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Pairwise Algorithm (du lourd, du très très lourd)</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param alpha:</span>
<span class="sd">    :param omega:</span>
<span class="sd">    :param source:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Compute Neighborhood :</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">compute_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="c1"># print(&quot; Neighborhood : &quot;, N)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Visited Nodes</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Visited Links</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>  <span class="c1"># Distance from s</span>
        <span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Previous node</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">alpha</span><span class="p">)</span>  <span class="c1"># Minimal time of arrival from previous node</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">omega</span><span class="p">)</span>  <span class="c1"># Maximal time of departure from this node</span>
        <span class="k">while</span> <span class="n">S</span> <span class="o">!=</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">S</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
            <span class="c1"># print(&quot; current node v : &quot;,v)</span>
            <span class="c1"># print(&quot; a[v] :&quot;,a[v],&quot; l[v] :&quot;,l[v])</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># print(&quot; \tcurrent neighbor w: &quot;,(t0,t1,w))</span>
                <span class="c1"># print(&quot; \ta[w] :&quot;,a[w])</span>
                <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># If the link is already over, we cannot take it (noshitsherlock)!</span>
                    <span class="n">new_path</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">new_path</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_path</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">t0</span><span class="p">)</span>  <span class="c1"># We can have an arrival already ahead of a link&#39;s beginning</span>
                        <span class="n">l</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
                    <span class="k">elif</span> <span class="n">new_path</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="ow">and</span> <span class="n">t0</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">t0</span><span class="p">)</span>
                        <span class="n">l</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
            <span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">L</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">([</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">N</span><span class="p">[</span><span class="n">v</span><span class="p">]])</span>
        <span class="c1"># Update current matrix</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">W</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">W</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">W</span></div>


<span class="c1"># def compute_shortest_path(wcc_storage_path, index_node_to_wcc, source, destination):</span>
<span class="c1">#     wcc_target = index_node_to_wcc[source].intersection(index_node_to_wcc[destination])</span>
<span class="c1">#</span>
<span class="c1">#     if not wcc_target:</span>
<span class="c1">#         print(source,&quot; is unreachable from &quot;,destination,&quot;, they are in disctinct weakly connected components !&quot;)</span>
<span class="c1">#         return None, None</span>
<span class="c1">#</span>
<span class="c1">#     ###########</span>
<span class="c1">#     gc.disable()</span>
<span class="c1">#     ###########</span>
<span class="c1">#     # Iterate on wcc to find wcc_target :</span>
<span class="c1">#     # TODO : wcc_to_offset in msgpack</span>
<span class="c1">#     P = []</span>
<span class="c1">#     A = []</span>
<span class="c1">#     L = []</span>
<span class="c1">#     distance = math.inf</span>
<span class="c1">#     with open(wcc_storage_path, &#39;rb&#39;) as input:</span>
<span class="c1">#         unpacker = msgpack.Unpacker(input, use_list=False)</span>
<span class="c1">#         for i in unpacker:</span>
<span class="c1">#             id_wcc = i[0]</span>
<span class="c1">#             if id_wcc in wcc_target:</span>
<span class="c1">#                 # print()</span>
<span class="c1">#                 alpha = i[1]</span>
<span class="c1">#                 omega = i[2]</span>
<span class="c1">#                 # print(&quot;Id wcc :&quot;,id_wcc, &quot; alpha : &quot;,alpha,&quot; omega : &quot;,omega)</span>
<span class="c1">#                 links = i[3]</span>
<span class="c1">#                 p,d,a,l = wcc_shortest_path(links,alpha,omega,source)</span>
<span class="c1">#                 # print(&quot;current distance :&quot;,d[destination])</span>
<span class="c1">#                 if d[destination] &lt; distance:</span>
<span class="c1">#                     P = [p]</span>
<span class="c1">#                     A = [a]</span>
<span class="c1">#                     L = [l]</span>
<span class="c1">#                     distance = d[destination]</span>
<span class="c1">#                 elif d[destination] == distance:</span>
<span class="c1">#                     P.append(p)</span>
<span class="c1">#                     A.append(a)</span>
<span class="c1">#                     L.append(l)</span>
<span class="c1">#                     distance = d[destination]</span>
<span class="c1">#</span>
<span class="c1">#     # print(&quot;P :&quot;,P)</span>
<span class="c1">#     # print(&quot;A :&quot;,A)</span>
<span class="c1">#     # print(&quot;L :&quot;,L)</span>
<span class="c1">#     shortest_paths = []</span>
<span class="c1">#     for p, a, l in zip(P, A, L):</span>
<span class="c1">#         # print(&quot;p :&quot;,p)</span>
<span class="c1">#         # print(&quot;a :&quot;,a)</span>
<span class="c1">#         # print(&quot;l :&quot;,l)</span>
<span class="c1">#         if destination in p:</span>
<span class="c1">#             shortest_paths.append(unpack_path(p,a,l,source,destination))</span>
<span class="c1">#     ###########</span>
<span class="c1">#     gc.enable()</span>
<span class="c1">#     ###########</span>
<span class="c1">#     return shortest_paths,distance</span>
<span class="c1">#</span>
<span class="c1"># def unpack_path(p,a,l,source,destination):</span>
<span class="c1">#     current = destination</span>
<span class="c1">#     s_path = []</span>
<span class="c1">#     while current != source:</span>
<span class="c1">#         pred = p[current]</span>
<span class="c1">#         s_path.append((a[current], l[current], pred, current))</span>
<span class="c1">#         if pred != source:</span>
<span class="c1">#             if a[current] &gt; l[pred]:  # Test if we stay on a node between two jumps</span>
<span class="c1">#                 s_path.append((l[pred], a[current], pred))</span>
<span class="c1">#             elif l[pred] &gt; l[current]:  # Test if we can take a jump in a path without breaking the coherency</span>
<span class="c1">#                 l[pred] = l[current]</span>
<span class="c1">#         current = pred</span>
<span class="c1">#     s_path = list(reversed(s_path))</span>
<span class="c1">#     return s_path</span>


<span class="c1"># def all_wcc_shortest_paths(links,alpha,omega,source):</span>
<span class="c1">#</span>
<span class="c1">#     # Compute Neighborhood :</span>
<span class="c1">#     N = compute_neighborhood(links)</span>
<span class="c1">#     nodes = set(N.keys())</span>
<span class="c1">#     S = set()  # Visited Nodes</span>
<span class="c1">#     L = set()  # Visited Links</span>
<span class="c1">#     d = {n: math.inf for n in nodes} # Distance from source</span>
<span class="c1">#     d[source] = 0</span>
<span class="c1">#     p = {}  # Previous node</span>
<span class="c1">#     a = defaultdict(lambda: [alpha])  # Minimal time of arrival from previous node</span>
<span class="c1">#     l = defaultdict(lambda: [omega])  # Maximal time of departure from this node</span>
<span class="c1">#     # print(&quot; Neighborhood : &quot;, N)</span>
<span class="c1">#     while S != nodes:</span>
<span class="c1">#         v = min(set(d.keys()) - S, key=d.get)</span>
<span class="c1">#         # print(&quot; current node v : &quot;,v)</span>
<span class="c1">#         # print(&quot; a[v] :&quot;,a[v],&quot; l[v] :&quot;,l[v])</span>
<span class="c1">#         for (t0, t1, w) in sorted(N[v] - L,key=lambda x:x[0]):</span>
<span class="c1">#             # print(&quot; \tcurrent neighbor : &quot;,(t0,t1,w))</span>
<span class="c1">#             # print(&quot; \ta[w] :&quot;,a[w])</span>
<span class="c1">#             if a[v][-1] &lt;= t1:  # If the link is already over, we cannot take it (noshitsherlock)!</span>
<span class="c1">#                 new_path = d[v] + 1</span>
<span class="c1">#                 if new_path &lt; d[w]:</span>
<span class="c1">#                     d[w] = new_path</span>
<span class="c1">#                     p[w] = [v]</span>
<span class="c1">#                     a[w] = [max(a[v][-1],t0)] # We can have an arrival already ahead of a link&#39;s beginning, because we arrive on the previous node earlier</span>
<span class="c1">#                     l[w] = [t1]</span>
<span class="c1">#                 elif new_path == d[w]:</span>
<span class="c1">#                     p[w].append(v)</span>
<span class="c1">#                     a[w].append(max(a[v][-1],t0))</span>
<span class="c1">#                     l[w].append(t1)</span>
<span class="c1">#         S.add(v)</span>
<span class="c1">#         L |= set([el for el in N[v]])</span>
<span class="c1">#     # print(&quot; a : &quot;,a)</span>
<span class="c1">#     # print(&quot; l : &quot;,l)</span>
<span class="c1">#     # print(&quot; d : &quot;,d)</span>
<span class="c1">#     # print(&quot; p : &quot;,p)</span>
<span class="c1">#     return p,d,a,l</span>

<span class="c1"># def compute_all_shortest_paths(wcc_storage_path, index_node_to_wcc, source, destination):</span>
<span class="c1">#     wcc_target = index_node_to_wcc[source].intersection(index_node_to_wcc[destination])</span>
<span class="c1">#</span>
<span class="c1">#     if not wcc_target:</span>
<span class="c1">#         print(&quot;\t&quot;,source,&quot; is unreachable from &quot;,destination,&quot;, they are in disctinct weakly connected components !&quot;)</span>
<span class="c1">#         return None,None</span>
<span class="c1">#</span>
<span class="c1">#     ###########</span>
<span class="c1">#     gc.disable()</span>
<span class="c1">#     ###########</span>
<span class="c1">#     # Iterate on wcc to find wcc_target :</span>
<span class="c1">#     # TODO : wcc_to_offset in msgpack</span>
<span class="c1">#     P = []</span>
<span class="c1">#     A = []</span>
<span class="c1">#     L = []</span>
<span class="c1">#     distance = math.inf</span>
<span class="c1">#     with open(wcc_storage_path, &#39;rb&#39;) as input:</span>
<span class="c1">#         unpacker = msgpack.Unpacker(input, use_list=False)</span>
<span class="c1">#         for i in unpacker:</span>
<span class="c1">#             id_wcc = i[0]</span>
<span class="c1">#             if id_wcc in wcc_target:</span>
<span class="c1">#                 # print()</span>
<span class="c1">#                 alpha = i[1]</span>
<span class="c1">#                 omega = i[2]</span>
<span class="c1">#                 # print(&quot;Id wcc :&quot;,id_wcc, &quot; alpha : &quot;,alpha,&quot; omega : &quot;,omega)</span>
<span class="c1">#                 links = i[3]</span>
<span class="c1">#                 p,d,a,l = all_wcc_shortest_paths(links,alpha,omega,source)</span>
<span class="c1">#                 # print(&quot;current distance :&quot;,d[destination])</span>
<span class="c1">#                 if d[destination] &lt; distance:</span>
<span class="c1">#                     P = [p]</span>
<span class="c1">#                     A = [a]</span>
<span class="c1">#                     L = [l]</span>
<span class="c1">#                     distance = d[destination]</span>
<span class="c1">#                 elif d[destination] == distance:</span>
<span class="c1">#                     P.append(p)</span>
<span class="c1">#                     A.append(a)</span>
<span class="c1">#                     L.append(l)</span>
<span class="c1">#     # print(&quot;P :&quot;,P)</span>
<span class="c1">#     # print(&quot;A :&quot;,A)</span>
<span class="c1">#     # print(&quot;L :&quot;,L)</span>
<span class="c1">#     shortest_paths = []</span>
<span class="c1">#     for p, a, l in zip(P, A, L):</span>
<span class="c1">#         if destination in p:</span>
<span class="c1">#             shortest_paths+=unpack_arborescent_paths(p,a,l,source,destination)</span>
<span class="c1">#     # print(&quot;final distance :&quot;,distance)</span>
<span class="c1">#     # print(&quot;final path :&quot;, shortest_paths)</span>
<span class="c1">#     ###########</span>
<span class="c1">#     gc.enable()</span>
<span class="c1">#     ###########</span>
<span class="c1">#     return shortest_paths,distance</span>
<span class="c1">#</span>
<span class="c1"># def unpack_arborescent_paths(p,a,l,source,destination):</span>
<span class="c1">#     p_list,a_list,l_list = [],[],[]</span>
<span class="c1">#     n_path = 0</span>
<span class="c1">#     current = destination</span>
<span class="c1">#     while current != source:</span>
<span class="c1">#         n_path = max(n_path,len(p[current]))</span>
<span class="c1">#         pred = p[current][-1]</span>
<span class="c1">#         current = pred</span>
<span class="c1">#     for i in range(n_path):</span>
<span class="c1">#         p_cur = {k : (v[i] if len(v) &gt; i else v[-1]) for k,v in p.items()}</span>
<span class="c1">#         a_cur = {k: (v[i] if len(v) &gt; i else v[-1]) for k, v in a.items()}</span>
<span class="c1">#         l_cur = {k: (v[i] if len(v) &gt; i else v[-1]) for k, v in l.items()}</span>
<span class="c1">#         p_list.append(p_cur)</span>
<span class="c1">#         a_list.append(a_cur)</span>
<span class="c1">#         l_list.append(l_cur)</span>
<span class="c1">#     shortest_paths= []</span>
<span class="c1">#     for p_cur,a_cur,l_cur in zip(p_list,a_list,l_list):</span>
<span class="c1">#         # print(&quot;p_cur :&quot;,p_cur)</span>
<span class="c1">#         # print(&quot;a_cur :&quot;,a_cur)</span>
<span class="c1">#         # print(&quot;l_cur :&quot;,l_cur)</span>
<span class="c1">#         shortest_paths.append(unpack_path(p_cur,a_cur,l_cur,source,destination))</span>
<span class="c1">#     return shortest_paths</span>

<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="construct_index_node_to_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.construct_index_node_to_wcc">[docs]</a><span class="k">def</span> <span class="nf">construct_index_node_to_wcc</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">):</span>
    <span class="n">index_node_to_wcc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># print(&quot;idwcc :&quot;,id_wcc)</span>
            <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># print(&quot;links :&quot;,links)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">)</span>
                    <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index_node_to_wcc</span></div>


<div class="viewcode-block" id="plot_shortest_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.plot_shortest_path">[docs]</a><span class="k">def</span> <span class="nf">plot_shortest_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#8f246b&quot;</span><span class="p">,</span> <span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Draw a path on the Stream Graph S</span>
<span class="sd">    :param S: A Stream Graph</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="n">label_nodes_by_letters</span><span class="p">)</span>
    <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path from &quot;</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="s2">&quot; to &quot;</span><span class="p">,</span><span class="n">destination</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">e</span>
            <span class="c1"># if S.nodes_to_label:</span>
            <span class="c1">#     n = int(S.nodes_to_label[n])</span>
            <span class="c1"># Plot a single rectangle.</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="c1"># alpha=0.5</span>
                                               <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span>
            <span class="c1"># if S.nodes_to_label:</span>
            <span class="c1">#     u,v = int(S.nodes_to_label[u]),int(S.nodes_to_label[v])</span>
            <span class="c1"># Plot a double rectangle (one for each extremities of link).</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">u</span> <span class="o">-</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;#4d79ff&#39;</span> <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">source</span> <span class="k">else</span> <span class="n">color</span><span class="p">),</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;#4d79ff&#39;</span> <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">source</span> <span class="k">else</span> <span class="n">color</span><span class="p">),</span>
                                               <span class="c1"># alpha=0.5,</span>
                                               <span class="p">))</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;#00cc00&#39;</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">destination</span> <span class="k">else</span> <span class="n">color</span><span class="p">),</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;#00cc00&#39;</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">destination</span> <span class="k">else</span> <span class="n">color</span><span class="p">),</span>
                                               <span class="c1"># alpha=0.5,</span>
                                               <span class="p">))</span>
            <span class="c1"># Plot reactangle for link</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                               <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span>
                                               <span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Shortest Path from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<span class="c1"># def test_sp_pairwise(S,wcc_storage_path):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     :param S:</span>
<span class="c1">#     :param wcc_storage_path:</span>
<span class="c1">#     :return:</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     W = lil_matrix((max(S.nodes) + 1, max(S.nodes) + 1))</span>
<span class="c1">#     with open(wcc_storage_path, &#39;rb&#39;) as input:</span>
<span class="c1">#         unpacker = msgpack.Unpacker(input, use_list=False)</span>
<span class="c1">#         for i in unpacker:</span>
<span class="c1">#             alpha = i[1]</span>
<span class="c1">#             omega = i[2]</span>
<span class="c1">#             # print(&quot;Id wcc :&quot;,i[0], &quot; alpha : &quot;,alpha,&quot; omega : &quot;,omega)</span>
<span class="c1">#             links = i[3]</span>
<span class="c1">#             W = wcc_shortest_path_pw(links, alpha, omega,W)</span>
<span class="c1">#     return W</span>

<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="get_node_presence"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.get_node_presence">[docs]</a><span class="k">def</span> <span class="nf">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">):</span>
    <span class="n">nodes_presence</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodes_presence</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes_presence</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nodes_presence</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes_presence</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nodes_presence</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_segmented_neighborhood"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_segmented_neighborhood">[docs]</a><span class="k">def</span> <span class="nf">compute_segmented_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    On veut des segments de noeuds comme clefs ainsi que dans les voisins (b,e,v) : [(t0,t1,(nt0,nt1,u))] :)</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param node_presence:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># See &#39;neighborhood_with_node_presence&#39; in stream.py</span>
    <span class="k">if</span> <span class="n">node_presence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="c1"># print(&quot; l :&quot;,l)</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">N</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">u</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">N</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">N</span></div>


<div class="viewcode-block" id="compute_links_to_segmented_nodes"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_links_to_segmented_nodes">[docs]</a><span class="k">def</span> <span class="nf">compute_links_to_segmented_nodes</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node_presence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">new_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">new_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">new_u</span><span class="p">,</span> <span class="n">new_v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">L</span></div>


<div class="viewcode-block" id="compute_links_to_segmented_nodes_with_source"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_links_to_segmented_nodes_with_source">[docs]</a><span class="k">def</span> <span class="nf">compute_links_to_segmented_nodes_with_source</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">node_presence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node_presence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># print(&quot;SOURCE :&quot;,source)</span>
    <span class="n">st</span><span class="p">,</span> <span class="n">lt</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">source</span>
    <span class="n">list_instant_of_jump</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">st</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">or</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">list_instant_of_jump</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># print(&quot;list instant of jump :&quot;,list_instant_of_jump)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">list_instant_of_jump</span><span class="p">)</span>  <span class="c1"># First instant of jump</span>
    <span class="c1">#  Put the links containing the source first.</span>
    <span class="n">links_with_source</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># Select links which haven&#39;t ended before threshold</span>
                <span class="k">if</span> <span class="n">t0</span> <span class="o">&lt;</span> <span class="n">st</span><span class="p">:</span>  <span class="c1"># Adjust links which have started before threshold</span>
                    <span class="n">t0</span> <span class="o">=</span> <span class="n">st</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                        <span class="n">new_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                        <span class="n">new_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t0</span> <span class="o">==</span> <span class="n">st</span> <span class="ow">and</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">==</span> <span class="n">s</span><span class="p">):</span>
                    <span class="n">links_with_source</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">new_u</span><span class="p">,</span> <span class="n">new_v</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">new_u</span><span class="p">,</span> <span class="n">new_v</span><span class="p">))</span>
    <span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">links_with_source</span> <span class="o">+</span> <span class="n">L</span>
    <span class="k">return</span> <span class="n">L</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="wcc_shortest_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.wcc_shortest_path">[docs]</a><span class="k">def</span> <span class="nf">wcc_shortest_path</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single Source Algorithm</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Compute Neighborhood :</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="c1"># print(&quot;SOURCE :&quot;,source)</span>
    <span class="c1"># print(&quot; Neighborhood : &quot;, N)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Visited Nodes</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Visited Links</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>  <span class="c1"># Distance from source</span>
    <span class="n">d</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Previous node</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>  <span class="c1"># defaultdict(lambda: alpha )  # Minimal time of arrival from previous node</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>  <span class="c1"># defaultdict(lambda: omega)  # Maximal time of departure from this node</span>
    <span class="k">while</span> <span class="n">J</span> <span class="o">!=</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">J</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>  <span class="c1"># TODO : Optimize this functions, make a priority queue see SCC UF</span>
        <span class="c1"># print(&quot; current node v : &quot;,v)</span>
        <span class="c1"># print(&quot; a[v] :&quot;,a[v],&quot; l[v] :&quot;,l[v])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Get corresponding node presence of &#39;n&#39;</span>
            <span class="c1"># print(&quot; \tcurrent neighbor w: &quot;,w)</span>
            <span class="c1"># print(&quot; \ta[w] :&quot;,a[w])</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># If the link is already over, we cannot take it (noshitsherlock)!</span>
                <span class="n">new_path</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">new_path</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_path</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">t0</span><span class="p">)</span>  <span class="c1"># We can have an arrival already ahead of a link&#39;s beginning</span>
                    <span class="n">l</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
                <span class="k">elif</span> <span class="n">new_path</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="ow">and</span> <span class="n">t0</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">t0</span><span class="p">)</span>
                    <span class="n">l</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="n">J</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">([</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">N</span><span class="p">[</span><span class="n">v</span><span class="p">]])</span>
    <span class="c1"># print(&quot; a : &quot;,a)</span>
    <span class="c1"># print(&quot; l : &quot;,l)</span>
    <span class="c1"># print(&quot; d : &quot;,d)</span>
    <span class="c1"># print(&quot; p : &quot;,p)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_shortest_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_shortest_path">[docs]</a><span class="k">def</span> <span class="nf">compute_shortest_path</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="n">wcc_target</span> <span class="o">=</span> <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">wcc_target</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="s2">&quot; is unreachable from &quot;</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span>
              <span class="s2">&quot;, they are in disctinct weakly connected components !&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1">###########</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="c1">###########</span>
    <span class="c1"># Iterate on wcc to find wcc_target :</span>
    <span class="c1"># TODO : wcc_to_offset in msgpack</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">effective_sources</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">effective_destinations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">wcc_target</span><span class="p">:</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="c1"># print(&quot;Id wcc :&quot;,id_wcc, &quot; alpha : &quot;,i[1],&quot; omega : &quot;,i[2])</span>

                <span class="c1"># Get potential Temporal Sources in WCC</span>
                <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
                <span class="n">potential_sources</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span>
                                                                        <span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
                <span class="n">min_time_source</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
                <span class="n">potential_destinations</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">destination</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span>
                                                                                  <span class="n">node_presence</span><span class="p">[</span><span class="n">destination</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
                                          <span class="k">if</span> <span class="n">t1</span> <span class="o">&gt;=</span> <span class="n">min_time_source</span><span class="p">]</span>
                <span class="c1"># print(&quot;Potential SOURCES :&quot;,potential_sources)</span>
                <span class="c1"># print(&quot;Potential DESTINATIONS :&quot;,potential_destinations)</span>
                <span class="c1"># Compute Neighborhood once for all</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">compute_augmented_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">potential_sources</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">wcc_shortest_path</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">potential_destinations</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
                            <span class="c1"># print(&quot;distance improvement :&quot;,d[n])</span>
                            <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                            <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
                            <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span>
                            <span class="n">effective_sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                            <span class="n">effective_destinations</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">distance</span><span class="p">:</span>
                            <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                            <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                            <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                            <span class="n">effective_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="n">effective_destinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># print(&quot;P :&quot;,P)</span>
    <span class="c1"># print(&quot;A :&quot;,A)</span>
    <span class="c1"># print(&quot;L :&quot;,L)</span>
    <span class="n">shortest_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">effective_sources</span><span class="p">,</span> <span class="n">effective_destinations</span><span class="p">):</span>
        <span class="c1"># print()</span>
        <span class="c1"># print(&quot;p :&quot;,p)</span>
        <span class="c1"># print(&quot;a :&quot;,a)</span>
        <span class="c1"># print(&quot;l :&quot;,l)</span>
        <span class="n">shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unpack_path</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="c1">###########</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="c1">###########</span>
    <span class="k">return</span> <span class="n">shortest_paths</span><span class="p">,</span> <span class="n">distance</span></div>


<div class="viewcode-block" id="unpack_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.unpack_path">[docs]</a><span class="k">def</span> <span class="nf">unpack_path</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Backtracking procedure in order to keep the coherency of the path.</span>
<span class="sd">    :param p: precedent node in the path</span>
<span class="sd">    :param a: arrival time in n</span>
<span class="sd">    :param l: leaving time of n</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param destination:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">destination</span>
    <span class="n">s_path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Très Technique Ne Pas Supprimer (#TTNPS).</span>
    <span class="k">while</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">current</span><span class="p">]</span>
        <span class="n">s_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">current</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">current</span><span class="p">],</span> <span class="n">pred</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">current</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">pred</span> <span class="o">!=</span> <span class="n">source</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">[</span><span class="n">pred</span><span class="p">]:</span>  <span class="c1"># Test if we stay on a node between two jumps</span>
                <span class="n">s_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">l</span><span class="p">[</span><span class="n">pred</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">current</span><span class="p">],</span> <span class="n">pred</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="n">pred</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>  <span class="c1"># Test if we can take a jump in a path without breaking the coherency</span>
                <span class="n">l</span><span class="p">[</span><span class="n">pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">current</span><span class="p">]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">pred</span>
    <span class="n">s_path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">s_path</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">s_path</span></div>


<span class="c1"># DEPRECATED</span>
<span class="c1"># def all_wcc_shortest_paths_v2(N,node_presence,source):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     :param N:</span>
<span class="c1">#     :param alpha:</span>
<span class="c1">#     :param omega:</span>
<span class="c1">#     :param source:</span>
<span class="c1">#     :param node_presence:</span>
<span class="c1">#     :return:</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     # Compute Neighborhood :</span>
<span class="c1">#     nodes = set(N.keys())</span>
<span class="c1">#     S = set()  # Visited Nodes</span>
<span class="c1">#     L = set()  # Visited Links</span>
<span class="c1">#     d = {n: math.inf for n in nodes} # Distance from source</span>
<span class="c1">#     d[source] = 0</span>
<span class="c1">#     p = {k: [] for k in nodes}  # Previous node</span>
<span class="c1">#     a = {k: [k[0]] for k in nodes}#defaultdict(lambda: [alpha] )  # Minimal time of arrival from previous node</span>
<span class="c1">#     l = {k: [k[1]] for k in nodes}#defaultdict(lambda: [omega] )  # Maximal time of departure from this node</span>
<span class="c1">#     while S != nodes:</span>
<span class="c1">#         v = min(set(d.keys()) - S, key=d.get)</span>
<span class="c1">#         print(&quot; current node v : &quot;,v)</span>
<span class="c1">#         print(&quot; a[v] :&quot;,a[v],&quot; l[v] :&quot;,l[v])</span>
<span class="c1">#         for (t0, t1, n) in sorted(N[v] - L,key=lambda x:x[0]):</span>
<span class="c1">#</span>
<span class="c1">#             # Get corresponding node presence</span>
<span class="c1">#             for nt0, nt1 in zip(node_presence[n][::2], node_presence[n][1::2]):</span>
<span class="c1">#                 if nt0 &lt;= t0 and t1 &lt;= nt1:</span>
<span class="c1">#                     w = (nt0,nt1,n)</span>
<span class="c1">#                     break</span>
<span class="c1">#</span>
<span class="c1">#             print(&quot; \tcurrent neighbor w :&quot;,w)</span>
<span class="c1">#             if a[v][-1] &lt;= t1:  # If the link is already over, we cannot take it (noshitsherlock)!</span>
<span class="c1">#                 new_path = d[v] + 1</span>
<span class="c1">#                 if new_path &lt; d[w]:</span>
<span class="c1">#                     d[w] = new_path</span>
<span class="c1">#                     p[w] = [v]</span>
<span class="c1">#                     a[w] = [max(a[v][-1],t0)] # We can have an arrival already ahead of a link&#39;s beginning, because we arrive on the previous node earlier</span>
<span class="c1">#                     l[w] = [t1]</span>
<span class="c1">#                 elif new_path == d[w]:</span>
<span class="c1">#                     p[w].append(v)</span>
<span class="c1">#                     a[w].append(max(a[v][-1],t0))</span>
<span class="c1">#                     l[w].append(t1)</span>
<span class="c1">#                 print(&quot; \ta[w] :&quot;, a[w],&quot; l[w] :&quot;,l[w])</span>
<span class="c1">#         S.add(v)</span>
<span class="c1">#         L |= set([el for el in N[v]])</span>
<span class="c1">#     # print(&quot; a : &quot;,a)</span>
<span class="c1">#     # print(&quot; l : &quot;,l)</span>
<span class="c1">#     # print(&quot; d : &quot;,d)</span>
<span class="c1">#     # print(&quot; p : &quot;,p)</span>
<span class="c1">#     return p,d,a,l</span>
<span class="c1"># @jit(nopython=False)</span>

<div class="viewcode-block" id="bfs"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.bfs">[docs]</a><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destinations</span><span class="p">):</span>
    <span class="n">path_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="p">[</span><span class="n">source</span><span class="p">])]</span>  <span class="c1"># Current path and pending paths</span>
    <span class="n">a_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]])]</span>  <span class="c1"># Minimal time of arrival from previous node</span>
    <span class="n">l_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>  <span class="c1"># Maximal time of departure from this node</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span>
         <span class="n">nodes</span><span class="p">}</span>  <span class="c1"># Distance from source, This variable, once assigned, is used as a threshold (yeah)</span>
    <span class="n">d</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
        <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">a_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">a_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="n">l_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">l_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># print(&quot;current node v : &quot;, v)</span>
        <span class="c1"># print(&quot; av :&quot;,av,&quot; lv :&quot;,lv)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># TODO : Optimize N and sorted : priority queue see SCC UF</span>
            <span class="c1"># Get corresponding node presence</span>

            <span class="c1"># print(&quot; \tcurrent neighbor w : &quot;,w)</span>
            <span class="k">if</span> <span class="n">av</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>
                <span class="n">new_path</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">new_path</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_path</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">destinations</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">d</span><span class="p">,</span> <span class="n">a_path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">t0</span><span class="p">)],</span> <span class="n">l_path</span> <span class="o">+</span> <span class="p">[</span><span class="n">t1</span><span class="p">],</span> <span class="n">w</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                        <span class="n">a_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">t0</span><span class="p">),</span> <span class="n">a_path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">t0</span><span class="p">)]))</span>
                        <span class="n">l_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span> <span class="n">l_path</span> <span class="o">+</span> <span class="p">[</span><span class="n">t1</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">new_path</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="c1"># a[w].append(max(a[v][-1],t0))</span>
                    <span class="c1"># l[w].append(t1)</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">destinations</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">d</span><span class="p">,</span> <span class="n">a_path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">t0</span><span class="p">)],</span> <span class="n">l_path</span> <span class="o">+</span> <span class="p">[</span><span class="n">t1</span><span class="p">],</span> <span class="n">w</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                        <span class="n">a_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">t0</span><span class="p">),</span> <span class="n">a_path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">t0</span><span class="p">)]))</span>
                        <span class="n">l_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span> <span class="n">l_path</span> <span class="o">+</span> <span class="p">[</span><span class="n">t1</span><span class="p">]))</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="all_wcc_shortest_paths"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.all_wcc_shortest_paths">[docs]</a><span class="k">def</span> <span class="nf">all_wcc_shortest_paths</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">potential_destinations</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    BFS Single Source, all possible shortest Paths ?</span>
<span class="sd">    :param N:</span>
<span class="sd">    :param alpha:</span>
<span class="sd">    :param omega:</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param node_presence:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Compute Neighborhood :</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">potential_destinations</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="compute_all_shortest_paths"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_all_shortest_paths">[docs]</a><span class="k">def</span> <span class="nf">compute_all_shortest_paths</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="n">wcc_target</span> <span class="o">=</span> <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">wcc_target</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="s2">&quot; is unreachable from &quot;</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span>
              <span class="s2">&quot;, they are in disctinct weakly connected components !&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1">###########</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="c1">###########</span>
    <span class="c1"># Iterate on wcc to find wcc_target :</span>
    <span class="c1"># TODO : wcc_to_offset in msgpack</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">effective_sources</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">effective_destinations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
            <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">wcc_target</span><span class="p">:</span>
                <span class="c1"># print()</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="c1"># print(&quot;Id wcc :&quot;,id_wcc, &quot; alpha : &quot;,alpha,&quot; omega : &quot;,omega)</span>
                <span class="c1"># Get potential Temporal Sources in WCC</span>
                <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
                <span class="n">potential_sources</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span>
                                                                        <span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>

                <span class="n">min_time_source</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
                <span class="n">potential_destinations</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">destination</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span>
                                                                                  <span class="n">node_presence</span><span class="p">[</span><span class="n">destination</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
                                          <span class="k">if</span> <span class="n">t1</span> <span class="o">&gt;=</span> <span class="n">min_time_source</span><span class="p">]</span>
                <span class="c1"># print(&quot;Potential SOURCES :&quot;,potential_sources)</span>
                <span class="c1"># print(&quot;Potential DESTINATIONS :&quot;,potential_destinations)</span>
                <span class="c1">#  Compute Neighorhood once for all</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">compute_augmented_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">potential_sources</span><span class="p">:</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="n">all_wcc_shortest_paths</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">potential_destinations</span><span class="p">)</span>
                    <span class="c1"># DISCRIMINER LES DESTINATIONS</span>
                    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">R</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
                            <span class="c1"># print(&quot;distance improvement :&quot;,d[dest])</span>
                            <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                            <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
                            <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span>
                            <span class="n">effective_sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                            <span class="n">effective_destinations</span> <span class="o">=</span> <span class="p">[</span><span class="n">dest</span><span class="p">]</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">==</span> <span class="n">distance</span><span class="p">:</span>
                            <span class="c1"># print(&quot;new shortest path&quot;)</span>
                            <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                            <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                            <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                            <span class="n">effective_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="n">effective_destinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
    <span class="c1"># print(&quot;P :&quot;,P)</span>
    <span class="c1"># print(&quot;A :&quot;,A)</span>
    <span class="c1"># print(&quot;L :&quot;,L)</span>
    <span class="n">shortest_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">effective_sources</span><span class="p">,</span> <span class="n">effective_destinations</span><span class="p">):</span>
        <span class="n">shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reformat_path</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
    <span class="c1"># print(&quot;final distance :&quot;,distance)</span>
    <span class="c1"># print(&quot;final path :&quot;, shortest_paths)</span>
    <span class="c1">###########</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="c1">###########</span>
    <span class="k">return</span> <span class="n">shortest_paths</span><span class="p">,</span> <span class="n">distance</span></div>


<div class="viewcode-block" id="reformat_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.reformat_path">[docs]</a><span class="k">def</span> <span class="nf">reformat_path</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="c1"># print(&quot;SOURCE :&quot;,source)</span>
    <span class="c1"># print(&quot;p :&quot;,p)</span>
    <span class="c1"># print(&quot;a :&quot;,a)</span>
    <span class="c1"># print(&quot;l :&quot;,l)</span>
    <span class="c1"># print(&quot;DESTINATION :&quot;,destination)</span>
    <span class="n">s_path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">:]):</span>
            <span class="n">s_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">:]),</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">s_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]),</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
    <span class="c1"># print(&quot;s path :&quot;,s_path)</span>
    <span class="k">return</span> <span class="n">s_path</span></div>


<span class="c1"># def unpack_arborescent_paths_v2(p,a,l,source,destination):</span>
<span class="c1">#     p_list,a_list,l_list = [],[],[]</span>
<span class="c1">#     n_path = 0</span>
<span class="c1">#     current = destination</span>
<span class="c1">#     while current != source:</span>
<span class="c1">#         n_path = max(n_path,len(p[current]))</span>
<span class="c1">#         pred = p[current][-1]</span>
<span class="c1">#         current = pred</span>
<span class="c1">#     for i in range(n_path):</span>
<span class="c1">#         p_cur = {k : (v[i] if len(v) &gt; i else v[-1]) for k,v in p.items() if len(v) &gt;0}</span>
<span class="c1">#         a_cur = {k: (v[i] if len(v) &gt; i else v[-1]) for k, v in a.items() if len(v) &gt;0}</span>
<span class="c1">#         l_cur = {k: (v[i] if len(v) &gt; i else v[-1]) for k, v in l.items() if len(v) &gt;0}</span>
<span class="c1">#         p_list.append(p_cur)</span>
<span class="c1">#         a_list.append(a_cur)</span>
<span class="c1">#         l_list.append(l_cur)</span>
<span class="c1">#     shortest_paths= []</span>
<span class="c1">#     for p_cur,a_cur,l_cur in zip(p_list,a_list,l_list):</span>
<span class="c1">#         print(&quot;p_cur :&quot;,p_cur)</span>
<span class="c1">#         print(&quot;a_cur :&quot;,a_cur)</span>
<span class="c1">#         print(&quot;l_cur :&quot;,l_cur)</span>
<span class="c1">#         shortest_paths.append(unpack_path_v2(p_cur,a_cur,l_cur,source,destination))</span>
<span class="c1">#     return shortest_paths</span>

<div class="viewcode-block" id="load_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.load_wcc">[docs]</a><span class="k">def</span> <span class="nf">load_wcc</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dict_offset_wcc</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">file_input</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">dict_offset_wcc</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
        <span class="c1"># assert i[0] == id_wcc</span>
        <span class="c1"># assert i[3] == tuple(sorted(i[3],key=lambda x:x[1]))</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">links</span></div>


<span class="c1"># # NOT WORKING</span>
<span class="c1"># def compute_distances_in_wcc_old(source, links, D):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     One pass algorithm to compute single source distances inside a WCC</span>
<span class="c1">#     :param source:</span>
<span class="c1">#     :param links:</span>
<span class="c1">#     :param D:</span>
<span class="c1">#     :return:</span>
<span class="c1">#     # TODO : Ne marche pas, il faut maintenir une structure pour chaque noeud,</span>
<span class="c1">#     # TODO : afin de retenir les temps d&#39;arrivées successifs !!!</span>
<span class="c1">#     # EN FAIT : cela n&#39;est surement pas possible du à la lnature continue des liens, il reste que dijkstra</span>
<span class="c1">#     # dynamique. En revanche une structure permettant de structurer les liens et de &#39;cutter&#39; aux endroits où</span>
<span class="c1">#     # les chemins peuvent démarrer (en fonction de la source) serait une heuristique intéressante !!</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     d = defaultdict(lambda: math.inf)  # Distance from a temporal node in sources</span>
<span class="c1">#     a = defaultdict(lambda: -math.inf)  # Minimum arrival time from a temporal node in sources</span>
<span class="c1">#     l = {}  # Maximal leaving time from a temporal node in sources</span>
<span class="c1">#     # Initialisation for the source</span>
<span class="c1">#     st = source[0]  # st : starting time</span>
<span class="c1">#     d[source] = 0</span>
<span class="c1">#     a[source] = st</span>
<span class="c1">#     l[source] = source[1]</span>
<span class="c1">#     # Reorder links in order to have</span>
<span class="c1">#     print(&quot;Source :&quot;, source)</span>
<span class="c1">#     for (t0, t1, u, v) in links:</span>
<span class="c1">#         if st &lt;= t1:  # We only process links existing after the apparition of the source</span>
<span class="c1">#             print(&quot;l :&quot;, (t0, t1, u, v))</span>
<span class="c1">#             if a[v] &lt;= t1:</span>
<span class="c1">#                 new_path = d[u] + 1</span>
<span class="c1">#                 if new_path &lt; d[v]:</span>
<span class="c1">#                     a[v] = max(a[u], t0)</span>
<span class="c1">#                     l[v] = t1</span>
<span class="c1">#                     d[v] = new_path</span>
<span class="c1">#             if a[u] &lt;= t1:</span>
<span class="c1">#                 new_path = d[v] + 1</span>
<span class="c1">#                 if new_path &lt; d[u]:</span>
<span class="c1">#                     a[u] = max(a[v], t0)</span>
<span class="c1">#                     l[u] = t1</span>
<span class="c1">#                     d[u] = new_path</span>
<span class="c1">#     for k, v in d.items():</span>
<span class="c1">#         n = k[2]</span>
<span class="c1">#         if n in D:</span>
<span class="c1">#             D[n] = min(D[n], v)</span>
<span class="c1">#         else:</span>
<span class="c1">#             D[n] = v</span>
<span class="c1">#     return D</span>


<div class="viewcode-block" id="compute_augmented_neighborhood"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_augmented_neighborhood">[docs]</a><span class="k">def</span> <span class="nf">compute_augmented_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    On veut des segments de noeuds comme clefs ainsi que dans les voisins (b,e,v) : [(t0,t1,(nt0,nt1,u))] :)</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param node_presence:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># See &#39;neighborhood_with_node_presence&#39; in stream.py</span>
    <span class="k">if</span> <span class="n">node_presence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
    <span class="c1"># N = defaultdict(set)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">SortedSet</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">nu</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">nv</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="n">N</span><span class="p">[</span><span class="n">nu</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">nv</span><span class="p">))</span>
            <span class="n">N</span><span class="p">[</span><span class="n">nv</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">nu</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">N</span></div>


<span class="k">def</span> <span class="nf">remove_dominated_elements_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    FSP : Fastest Shortest Path</span>
<span class="sd">    :param L:</span>
<span class="sd">    :param v:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">pred_dv</span><span class="p">,</span> <span class="n">pred_av</span><span class="p">,</span> <span class="n">pred_lv</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">])):</span>
        <span class="n">Lv</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dv</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">lv</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Lv</span>
        <span class="k">if</span> <span class="n">dv</span> <span class="o">&gt;</span> <span class="n">pred_dv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;=</span> <span class="n">pred_av</span><span class="p">:</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Lv</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dv</span> <span class="o">==</span> <span class="n">pred_dv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;</span> <span class="n">pred_av</span> <span class="ow">and</span> <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">pred_lv</span><span class="p">:</span>  <span class="c1"># and av-lv &gt; pred_av-pred_lv:</span>
            <span class="c1"># If the path arrive later and the duration is worse for the same distance we can remove it !</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Lv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred_av</span> <span class="o">=</span> <span class="n">av</span>
            <span class="n">pred_dv</span> <span class="o">=</span> <span class="n">dv</span>
            <span class="n">pred_lv</span> <span class="o">=</span> <span class="n">lv</span>
    <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">to_remove</span>


<span class="k">def</span> <span class="nf">update_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    FSP : Fastest Shortest Path</span>
<span class="sd">    Update L structure</span>
<span class="sd">    Elements of L are sorted by their distances, (and the better the distance is the worse the arrival time is).</span>
<span class="sd">    We just need to add to L[v] the last element in L[u] before</span>
<span class="sd">    the beginning of the link (t0) and every other element during the link (from t0 to t1).</span>
<span class="sd">    :param L:</span>
<span class="sd">    :param t0:</span>
<span class="sd">    :param t1:</span>
<span class="sd">    :param u:</span>
<span class="sd">    :param v:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">du</span><span class="p">,</span> <span class="n">au</span><span class="p">,</span> <span class="n">lu</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1">#  We take arrival times compatible with the link.</span>
            <span class="n">new_arrival</span> <span class="o">=</span> <span class="n">au</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">du</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">new_leaving_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">lu</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">:</span>  <span class="c1"># We have just added the last element of L[u] before the beginning of the link given the ordering of L.</span>
                <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">new_path</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">new_leaving_time</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
                <span class="k">break</span>
            <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">new_path</span><span class="p">,</span> <span class="n">new_arrival</span><span class="p">,</span> <span class="n">new_leaving_time</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>


<div class="viewcode-block" id="compute_FSP_in_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_FSP_in_wcc">[docs]</a><span class="k">def</span> <span class="nf">compute_FSP_in_wcc</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">P</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    One pass algorithm to compute single source distances inside a WCC</span>
<span class="sd">    BFS like (to respect the temporal order of the links).</span>
<span class="sd">    We can visit each node several time, but we visit links only once !!</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param D: Containing the distances to each node from the source.</span>
<span class="sd">    :param A: containing the best duration for a shortest path. (fastest shortest path).</span>
<span class="sd">    :param P: Containing the current marked out shortest path.</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># set of visited links</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">SortedSet</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">SortedSet</span><span class="p">()</span>
    <span class="c1"># Initialisation for the source</span>
    <span class="n">L</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">))</span>  <span class="c1"># (distance, arrival_time, leaving time, predecessor)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">))</span>  <span class="c1"># (arrival_time, source)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">au</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># min_au = min([i[1] for i in L[u]])</span>
        <span class="c1"># print(&quot;u :&quot;,u)</span>
        <span class="n">visited_neihgbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">N</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># If we can take the link</span>
                    <span class="n">J</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="c1"># Get the best distances and arrival times compatible with the link !</span>
                    <span class="c1"># A better distance for &#39;v&#39; can exist but with a later arrival time which isn&#39;t compatible with the current link.</span>
                    <span class="n">update_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="c1"># We must remove useless elements from L[v]:</span>
                    <span class="c1"># Every path that is a longer than a previous one and that arrives after or at the same time</span>
                    <span class="c1"># But we can keep longer paths that arrives before (in case of a shortcut link not yet analyzed)</span>
                    <span class="n">remove_dominated_elements_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_neihgbors</span><span class="p">:</span>
                        <span class="n">av</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">au</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">av</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                        <span class="n">visited_neihgbors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1"># Get the best distance realized sor far for each segment of nodes.</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lambdas</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">distance</span><span class="p">]</span>
        <span class="c1"># print(&quot;k :&quot;, k)</span>
        <span class="c1"># print(&quot;L :&quot;, v)</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lambdas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
                <span class="n">update_path_SP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">duration</span><span class="p">)</span>
                <span class="n">update_path_SP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
            <span class="n">update_path_SP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">P</span></div>


<div class="viewcode-block" id="update_path_SP"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.update_path_SP">[docs]</a><span class="k">def</span> <span class="nf">update_path_SP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Update the best Path so far : P[n]</span>
<span class="sd">    :param L:</span>
<span class="sd">    :param P:</span>
<span class="sd">    :param k:</span>
<span class="sd">    :param v:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">arrival_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">leaving_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">predecessor_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrival_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">leaving_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">predecessor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># arrival_list.append()</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># destination node</span>
    <span class="c1"># print()</span>
    <span class="c1"># print(&quot;\t destination node: &quot;, k)</span>
    <span class="c1"># print(&quot;\t predecessors list :&quot;, predecessor_list)</span>
    <span class="c1"># print(&quot;\t arrival list :&quot;, arrival_list)</span>
    <span class="c1"># print(&quot;\t leaving list :&quot;, leaving_list)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">predecessor_list</span><span class="p">:</span>
        <span class="n">P</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">P</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">reformat_path_SP</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">predecessor_list</span><span class="p">,</span> <span class="n">arrival_list</span><span class="p">,</span> <span class="n">leaving_list</span><span class="p">)</span></div>
    <span class="c1"># We must update P[n]</span>


<div class="viewcode-block" id="reformat_path_SP"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.reformat_path_SP">[docs]</a><span class="k">def</span> <span class="nf">reformat_path_SP</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="n">s_path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># The path is in reverse !!</span>
        <span class="n">s_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
        <span class="c1"># s_path.append((a[i], min(l[i::-1]), p[i][2], p[i - 1][2]))</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># if there is a gap in the path i.e. we have to wait on a node !!</span>
            <span class="n">s_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
    <span class="c1"># print(&quot;s path :&quot;,s_path)</span>
    <span class="n">s_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">dest</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">s_path</span></div>


<div class="viewcode-block" id="compute_distances_and_duration_in_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_distances_and_duration_in_wcc">[docs]</a><span class="k">def</span> <span class="nf">compute_distances_and_duration_in_wcc</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    One pass algorithm to compute single source distances inside a WCC</span>
<span class="sd">    BFS like (to respect the temporal order of the links).</span>
<span class="sd">    We can visit each node several time, but we visit links only once !!</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param D: Containing the distances to each node from the source.</span>
<span class="sd">    :param A: containing the best duration for a shortest path. (fastest shortest path).</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># set of visited links</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">SortedSet</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">SortedSet</span><span class="p">()</span>
    <span class="c1"># Initialisation for the source</span>
    <span class="n">L</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># (distance, arrival_time, leaving time)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">))</span>  <span class="c1"># (arrival_time, source)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">au</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># min_au = min([i[1] for i in L[u]])</span>
        <span class="c1"># print(&quot;u :&quot;,u)</span>
        <span class="n">visited_neihgbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">N</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># If we can take the link</span>
                    <span class="n">J</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="c1"># Get the best distances and arrival times compatible with the link !</span>
                    <span class="c1"># A better distance for &#39;v&#39; can exist but with a later arrival time which isn&#39;t compatible with the current link.</span>
                    <span class="n">update_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="c1"># We must remove useless elements from L[v]:</span>
                    <span class="c1"># Every path that is a longer than a previous one and that arrives after or at the same time</span>
                    <span class="c1"># But we can keep longer paths that arrives before (in case of a shortcut link not yet analyzed)</span>
                    <span class="n">remove_dominated_elements_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_neihgbors</span><span class="p">:</span>
                        <span class="n">av</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">au</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">av</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                        <span class="n">visited_neihgbors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1"># Get the best distance realized sor far for each segment of nodes.</span>
    <span class="c1"># print(&quot;Sources :&quot;,sources)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lambdas</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">distance</span><span class="p">]</span>
        <span class="c1"># print(&quot;k :&quot;, k)</span>
        <span class="c1"># print(&quot;L :&quot;, v)</span>
        <span class="c1"># print(&quot;lambdas :&quot;,lambdas)</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lambdas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">duration</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span></div>


<div class="viewcode-block" id="remove_dominated_elements_FSP"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.remove_dominated_elements_FSP">[docs]</a><span class="k">def</span> <span class="nf">remove_dominated_elements_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    FSP : Fastest Shortest Path</span>
<span class="sd">    :param L:</span>
<span class="sd">    :param v:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">pred_dv</span><span class="p">,</span> <span class="n">pred_av</span><span class="p">,</span> <span class="n">pred_lv</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">])):</span>
        <span class="n">dv</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dv</span> <span class="o">&gt;</span> <span class="n">pred_dv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;=</span> <span class="n">pred_av</span><span class="p">:</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">dv</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">lv</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">dv</span> <span class="o">==</span> <span class="n">pred_dv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;</span> <span class="n">pred_av</span> <span class="ow">and</span> <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">pred_lv</span><span class="p">:</span>  <span class="c1"># and av-lv &gt; pred_av-pred_lv:</span>
            <span class="c1"># If the path arrive later and the duration is worse for the same distance we can remove it !</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">dv</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">lv</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred_av</span> <span class="o">=</span> <span class="n">av</span>
            <span class="n">pred_dv</span> <span class="o">=</span> <span class="n">dv</span>
            <span class="n">pred_lv</span> <span class="o">=</span> <span class="n">lv</span>
    <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">to_remove</span></div>


<div class="viewcode-block" id="update_FSP"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.update_FSP">[docs]</a><span class="k">def</span> <span class="nf">update_FSP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    FSP : Fastest Shortest Path</span>
<span class="sd">    Update L structure</span>
<span class="sd">    Elements of L are sorted by their distances, (and the better the distance is the worse the arrival time is).</span>
<span class="sd">    We just need to add to L[v] the last element in L[u] before</span>
<span class="sd">    the beginning of the link (t0) and every other element during the link (from t0 to t1).</span>
<span class="sd">    :param L:</span>
<span class="sd">    :param t0:</span>
<span class="sd">    :param t1:</span>
<span class="sd">    :param u:</span>
<span class="sd">    :param v:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">du</span><span class="p">,</span> <span class="n">au</span><span class="p">,</span> <span class="n">lu</span><span class="p">)</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1">#  We take arrival times compatible with the link.</span>
            <span class="n">new_arrival</span> <span class="o">=</span> <span class="n">au</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">du</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">new_leaving_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">lu</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">:</span>  <span class="c1"># We have just added the last element of L[u] before the beginning of the link given the ordering of L.</span>
                <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">new_path</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">new_leaving_time</span><span class="p">))</span>
                <span class="k">break</span>
            <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">new_path</span><span class="p">,</span> <span class="n">new_arrival</span><span class="p">,</span> <span class="n">new_leaving_time</span><span class="p">))</span></div>




<div class="viewcode-block" id="compute_distances_in_wcc"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_distances_in_wcc">[docs]</a><span class="k">def</span> <span class="nf">compute_distances_in_wcc</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    One pass algorithm to compute single source distances inside a WCC</span>
<span class="sd">    BFS like (to respect the temporal order of the links).</span>
<span class="sd">    We can visit each node several time, but we visit links only once !!</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param D:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># set of visited segmented_nodes</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">SortedSet</span><span class="p">)</span>
    <span class="c1"># L = defaultdict(ValueSortedDict)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">SortedSet</span><span class="p">()</span>
    <span class="c1"># Initialisation for the source</span>
    <span class="n">L</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># (distance, arrival_time)</span>
    <span class="c1"># L[source][source[0]] = 0  #  arrival_time -&gt; distance</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">))</span>  <span class="c1"># (arrival_time, distance)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">tu</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">N</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span><span class="p">:</span>
                <span class="c1"># We will not visit links that connect u and v several time, because they are dominated...</span>
                <span class="c1"># Do not apply for fastest paths, as we can leave later to obtain a fastest path.</span>
                <span class="k">if</span> <span class="n">tu</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># If we can take the link</span>
                    <span class="c1"># Get the best distances and arrival times compatible with the link !</span>
                    <span class="c1"># A better distance for &#39;v&#39; can exist but with a later arrival time which isn&#39;t compatible with the current link.</span>
                    <span class="n">update_paths</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="c1"># We must remove useless elements from L[v]:</span>
                    <span class="c1"># Every path that is a longer than a previous one and that arrives after or at the same time</span>
                    <span class="c1"># But we can keep longer paths that arrives before (in case of a shortcut link not yet analyzed)</span>
                    <span class="n">remove_dominated_elements</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

                    <span class="c1"># update_L(L,t0,t1,u,v)</span>
                    <span class="n">av</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tu</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">av</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="n">J</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1"># Get the best distance realized sor far for each segment of nodes.</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># _,d = v.peekitem(0)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
            <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
    <span class="c1"># print(&quot;D :&quot;,D)</span>
    <span class="k">return</span> <span class="n">D</span></div>


<div class="viewcode-block" id="compute_distances_in_wcc_v2"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_distances_in_wcc_v2">[docs]</a><span class="k">def</span> <span class="nf">compute_distances_in_wcc_v2</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    One pass algorithm to compute single source distances inside a WCC</span>
<span class="sd">    BFS like (to respect the temporal order of the links).</span>
<span class="sd">    We can visit each node several time, but we visit links only once !!</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param links:</span>
<span class="sd">    :param D:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># set of visited segmented_nodes</span>
    <span class="c1"># L = defaultdict(SortedSet)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">ValueSortedDict</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">SortedSet</span><span class="p">()</span>
    <span class="c1"># Initialisation for the source</span>
    <span class="c1"># L[source].add((0, source[0]))  # (distance, arrival_time)</span>
    <span class="n">L</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">#  arrival_time -&gt; distance</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">))</span>  <span class="c1"># (arrival_time, distance)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">tu</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">N</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">J</span><span class="p">:</span>
                <span class="c1"># We will not visit links that connect u and v several time, because they are dominated...</span>
                <span class="c1"># Do not apply for fastest paths, as we can leave later to obtain a fastest path.</span>
                <span class="k">if</span> <span class="n">tu</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1"># If we can take the link</span>
                    <span class="c1"># Get the best distances and arrival times compatible with the link !</span>
                    <span class="c1"># A better distance for &#39;v&#39; can exist but with a later arrival time which isn&#39;t compatible with the current link.</span>
                    <span class="c1"># update_paths(L, t0, t1, u, v)</span>
                    <span class="c1"># We must remove useless elements from L[v]:</span>
                    <span class="c1"># Every path that is a longer than a previous one and that arrives after or at the same time</span>
                    <span class="c1"># But we can keep longer paths that arrives before (in case of a shortcut link not yet analyzed)</span>
                    <span class="c1"># remove_dominated_elements(L, v)</span>

                    <span class="n">update_L</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">av</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tu</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">av</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="n">J</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1"># Get the best distance realized sor far for each segment of nodes.</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># d = v[0][0]</span>
        <span class="n">_</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
            <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
    <span class="c1"># print(&quot;D :&quot;,D)</span>
    <span class="k">return</span> <span class="n">D</span></div>


<div class="viewcode-block" id="update_L"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.update_L">[docs]</a><span class="k">def</span> <span class="nf">update_L</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="c1"># Chopper les au,du qui sont entre t0 et t1</span>
    <span class="n">potential_insertion</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">au</span><span class="p">,</span><span class="n">du</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>
            <span class="n">new_arrival</span> <span class="o">=</span> <span class="n">au</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">du</span> <span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">:</span>
                <span class="n">potential_insertion</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span><span class="n">new_path</span><span class="p">))</span>
                <span class="k">break</span>
            <span class="n">potential_insertion</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_arrival</span><span class="p">,</span><span class="n">new_path</span><span class="p">))</span>
    <span class="c1"># Les potential insertion sont dans Lu donc ils sont bien classés (pas de domination)</span>
    <span class="c1"># Regarder si on peut les insérer dans Lv</span>
    <span class="c1">#    - si on peut : virer les éléments de Lv qui sont dominés</span>
    <span class="c1">#    - si on ne peut pas : ne pas modifier Lv</span>
    <span class="n">to_insert</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="n">to_insert</span> <span class="o">=</span> <span class="n">potential_insertion</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">potential_av</span><span class="p">,</span><span class="n">potential_dv</span> <span class="ow">in</span> <span class="n">potential_insertion</span><span class="p">:</span>
            <span class="c1"># On va de temps d&#39;arrivée de plus en plus petits</span>
            <span class="c1"># On va de distances de plus en plus grandes</span>
            <span class="k">if</span> <span class="n">potential_av</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">potential_av</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">potential_av</span><span class="p">],</span><span class="n">potential_dv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In the following potential_av cannot be equal to ref_av</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">done</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">ref_av</span><span class="p">,</span><span class="n">ref_dv</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">potential_dv</span> <span class="o">&gt;=</span> <span class="n">ref_dv</span> <span class="ow">and</span> <span class="n">potential_av</span> <span class="o">&gt;</span> <span class="n">ref_av</span><span class="p">:</span>
                        <span class="c1"># Our element is dominated</span>
                        <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">potential_dv</span> <span class="o">&lt;</span> <span class="n">ref_dv</span> <span class="ow">and</span> <span class="n">potential_av</span> <span class="o">&lt;</span> <span class="n">ref_av</span> <span class="p">:</span>
                        <span class="c1"># current element dominate the reference element, we remove it</span>
                        <span class="k">del</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">ref_av</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ref_av</span> <span class="o">&lt;</span> <span class="n">potential_av</span><span class="p">:</span>
                        <span class="c1"># We cannot place this element further, we&#39;re done !</span>
                        <span class="c1"># We insert later to not augment the size of Lv</span>
                        <span class="n">to_insert</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">potential_av</span><span class="p">,</span><span class="n">potential_dv</span><span class="p">))</span>
                        <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># First element in List</span>
                        <span class="n">to_insert</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">potential_av</span><span class="p">,</span><span class="n">potential_dv</span><span class="p">))</span>
                        <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Final Insertion</span>
    <span class="k">for</span> <span class="n">new_av</span><span class="p">,</span><span class="n">new_dv</span> <span class="ow">in</span> <span class="n">to_insert</span><span class="p">:</span>
        <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">new_av</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dv</span></div>


<div class="viewcode-block" id="remove_dominated_elements"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.remove_dominated_elements">[docs]</a><span class="k">def</span> <span class="nf">remove_dominated_elements</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># Pour FASTEST SHORTEST PATH :</span>
    <span class="c1"># pred_dv, pred_av, pred_lv = L[v][0]</span>
    <span class="c1"># for i in range(1, len(L[v])):</span>
    <span class="c1">#     dv, av, lv = L[v][i]</span>
    <span class="c1">#     if dv &gt; pred_dv and av &gt;= pred_av:</span>
    <span class="c1">#         to_remove.add((dv, av, lv))</span>
    <span class="c1">#     elif dv == pred_dv and av &gt; pred_av and av-lv &gt; pred_av-pred_lv:</span>
    <span class="c1">#         to_remove.add((dv, av,lv))</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         pred_av = av</span>
    <span class="c1">#         pred_dv = dv</span>
    <span class="c1">#         pred_lv = lv</span>
    <span class="c1"># L[v] -= to_remove</span>
    <span class="c1">#############################</span>

    <span class="n">pred_dv</span><span class="p">,</span> <span class="n">pred_av</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">])):</span>
        <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dv</span> <span class="o">&gt;</span> <span class="n">pred_dv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;=</span> <span class="n">pred_av</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dv</span> <span class="o">==</span> <span class="n">pred_dv</span> <span class="ow">and</span> <span class="n">av</span> <span class="o">&gt;</span> <span class="n">pred_av</span><span class="p">):</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">dv</span><span class="p">,</span> <span class="n">av</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred_av</span> <span class="o">=</span> <span class="n">av</span>
            <span class="n">pred_dv</span> <span class="o">=</span> <span class="n">dv</span>
    <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">to_remove</span></div>


<div class="viewcode-block" id="update_paths"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.update_paths">[docs]</a><span class="k">def</span> <span class="nf">update_paths</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Update L structure</span>
<span class="sd">    Elements of L are sorted by their distances, (and the better the distance is the worse the arrival time is).</span>
<span class="sd">    We just need to add to L[v] the last element in L[u] before</span>
<span class="sd">    the beginning of the link (t0) and every other element during the link (from t0 to t1).</span>
<span class="sd">    :param L:</span>
<span class="sd">    :param t0:</span>
<span class="sd">    :param t1:</span>
<span class="sd">    :param u:</span>
<span class="sd">    :param v:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># The Function is efficient, improvement ? : bissect in order to only add elements between t1 and t0</span>
    <span class="c1"># and the last element with a_i &lt;= t0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">du</span><span class="p">,</span> <span class="n">au</span><span class="p">)</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>  <span class="c1">#  We take arrival times compatible with the link.</span>
            <span class="n">new_arrival</span> <span class="o">=</span> <span class="n">au</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">du</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">au</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">:</span>  <span class="c1"># We have just added the last element of L[u] before the beginning of the link given the ordering of L.</span>
                <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">new_path</span><span class="p">,</span> <span class="n">t0</span><span class="p">))</span>
                <span class="k">break</span>
            <span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">new_path</span><span class="p">,</span> <span class="n">new_arrival</span><span class="p">))</span></div>


<div class="viewcode-block" id="compute_distances"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_distances">[docs]</a><span class="k">def</span> <span class="nf">compute_distances</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">,</span> <span class="n">id_wcc_to_node_presence</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single source computation of distances (length of any shortest path).</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param wcc_storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key : destination node ; value : distance</span>
    <span class="n">unvisited_wcc</span> <span class="o">=</span> <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="c1"># print(&quot;unvisited wcc :&quot;,unvisited_wcc)</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">for</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">unvisited_wcc</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">id_wcc_to_node_presence</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="c1"># Get potential Temporal Sources in WCC</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
        <span class="c1"># print(&quot;N augmented neighborhood :&quot;,N)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">compute_distances_in_wcc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
        <span class="c1"># print(&quot;sources :&quot;,sources)</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">return</span> <span class="n">D</span></div>


<div class="viewcode-block" id="compute_distances_and_duration_FSP"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_distances_and_duration_FSP">[docs]</a><span class="k">def</span> <span class="nf">compute_distances_and_duration_FSP</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">,</span>
                                       <span class="n">id_wcc_to_node_presence</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single source computation of distances (length of any shortest path).</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param wcc_storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key : destination node ; value : distance</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key : destination node ; value : duration</span>
    <span class="n">unvisited_wcc</span> <span class="o">=</span> <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="c1"># print(&quot;unvisited wcc :&quot;,unvisited_wcc)</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">for</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">unvisited_wcc</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">id_wcc_to_node_presence</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="c1"># Get potential Temporal Sources in WCC</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
        <span class="c1"># print(&quot;N augmented neighborhood :&quot;,N)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="n">D</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">compute_distances_and_duration_in_wcc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="c1"># print(&quot;\nsources :&quot;,sources)</span>
        <span class="c1"># print(&quot;D :&quot;,D)</span>
        <span class="c1"># print(&quot;A :&quot;,A)</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span></div>


<div class="viewcode-block" id="compute_path_FSP"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.compute_path_FSP">[docs]</a><span class="k">def</span> <span class="nf">compute_path_FSP</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">,</span> <span class="n">id_wcc_to_node_presence</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single source computation of distances (length of any shortest path).</span>
<span class="sd">    :param source:</span>
<span class="sd">    :param wcc_storage_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># print(&quot;Source :&quot;,source)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key : destination node ; value : distance</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key : destination node ; value : duration</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key : destiantion node ; value : detailed FSP</span>
    <span class="n">unvisited_wcc</span> <span class="o">=</span> <span class="n">index_node_to_wcc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">for</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">unvisited_wcc</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">id_wcc_to_node_presence</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="c1"># Get potential Temporal Sources in WCC</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][::</span><span class="mi">2</span><span class="p">],</span> <span class="n">node_presence</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
        <span class="c1"># print(&quot;N augmented neighborhood :&quot;,N)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="c1"># print(&quot;########## source :&quot;, s)</span>
            <span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">compute_FSP_in_wcc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sources :&quot;</span><span class="p">,</span><span class="n">sources</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;D :&quot;</span><span class="p">,</span><span class="n">D</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A :&quot;</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
        <span class="c1"># print(&quot;P :&quot;,P)</span>
    <span class="c1">####################</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="c1">####################</span>
    <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span></div>


<span class="c1">###########################################</span>
<span class="c1">#       Fuzzing Functions (TEST)          #</span>
<span class="c1">###########################################</span>

<div class="viewcode-block" id="fuzz_shortest_path"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.fuzz_shortest_path">[docs]</a><span class="k">def</span> <span class="nf">fuzz_shortest_path</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">random_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">high_degree_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">random_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">high_degree_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># DEGREE LIKE DESCRIBE IN FORMALISM</span>
        <span class="c1"># d = S.degrees()</span>
        <span class="c1"># nodes = [k for k,v in sorted(d.items(),reverse=True, key = lambda x:x[1])][0:10] #tenth highest degree nodes</span>
        <span class="c1"># print([(k,v) for k, v in sorted(d.items(), reverse=True, key=lambda x: x[1])][0:10])</span>
        <span class="c1"># CLASSICAL DEGREE NOTION</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">degrees_partition</span><span class="p">()</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">degree</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">S</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
    <span class="n">nb_paths_to_compute</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of paths to compute :&quot;</span><span class="p">,</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="n">cnt_1_hop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_multi_hops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_inf_dist</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">shortest_paths</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">compute_shortest_path</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">nb_of_paths</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shortest_paths</span><span class="p">)</span> <span class="k">if</span> <span class="n">shortest_paths</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
                <span class="c1"># print(&quot;Shortest Path between &quot;, u, &quot; and &quot;, v, &quot; (distance = &quot;, distance,</span>
                <span class="c1">#       &quot;, nb of paths = &quot;,nb_of_paths, &quot;): &quot;)</span>
                <span class="k">if</span> <span class="n">nb_of_paths</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cnt_inf_dist</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">distance</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cnt_1_hop</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt_multi_hops</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">time_end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Paths distances computed in &quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time per distance :&quot;</span><span class="p">,</span> <span class="n">time_end</span> <span class="o">/</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None distances :&quot;</span><span class="p">,</span> <span class="n">cnt_inf_dist</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1 hop distances :&quot;</span><span class="p">,</span> <span class="n">cnt_1_hop</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Multi hop distances :&quot;</span><span class="p">,</span> <span class="n">cnt_multi_hops</span><span class="p">)</span></div>


<span class="c1"># @jit(nopython=False)</span>
<div class="viewcode-block" id="fuzz_all_shortest_paths"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.fuzz_all_shortest_paths">[docs]</a><span class="k">def</span> <span class="nf">fuzz_all_shortest_paths</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">random_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">high_degree_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">random_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">high_degree_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># DEGREE LIKE DESCRIBE IN FORMALISM</span>
        <span class="c1"># d = S.degrees()</span>
        <span class="c1"># nodes = [k for k,v in sorted(d.items(),reverse=True, key = lambda x:x[1])][0:10] #tenth highest degree nodes</span>
        <span class="c1"># print([(k,v) for k, v in sorted(d.items(), reverse=True, key=lambda x: x[1])][0:10])</span>
        <span class="c1"># CLASSICAL DEGREE NOTION</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">degrees_partition</span><span class="p">()</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">degree</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">S</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
    <span class="n">nb_paths_to_compute</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of paths to compute :&quot;</span><span class="p">,</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="n">cnt_1_hop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_multi_hops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_inf_dist</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">shortest_paths</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">compute_all_shortest_paths</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">nb_of_paths</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shortest_paths</span><span class="p">)</span> <span class="k">if</span> <span class="n">shortest_paths</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nb_of_paths</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cnt_inf_dist</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">distance</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cnt_1_hop</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt_multi_hops</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Shortest Paths between &quot;,u,&quot; and &quot;,v,&quot; (distance = &quot;,distance,</span>
                    <span class="c1">#       &quot;, nb of paths = &quot;,nb_of_paths,&quot;): &quot;)</span>
    <span class="n">time_end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Paths distances computed in &quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time per distance :&quot;</span><span class="p">,</span> <span class="n">time_end</span> <span class="o">/</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None distances :&quot;</span><span class="p">,</span> <span class="n">cnt_inf_dist</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1 hop distances :&quot;</span><span class="p">,</span> <span class="n">cnt_1_hop</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Multi hop distances :&quot;</span><span class="p">,</span> <span class="n">cnt_multi_hops</span><span class="p">)</span></div>


<div class="viewcode-block" id="fuzz_distances"><a class="viewcode-back" href="../../../straph.streaming_algorithms.html#straph.streaming_algorithms.shortest_path_streaming.fuzz_distances">[docs]</a><span class="k">def</span> <span class="nf">fuzz_distances</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span> <span class="n">dict_offset_wcc</span><span class="p">,</span> <span class="n">random_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">high_degree_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">time_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">random_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">high_degree_nodes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># DEGREE LIKE DESCRIBE IN FORMALISM</span>
        <span class="c1"># d = S.degrees()</span>
        <span class="c1"># nodes = [k for k,v in sorted(d.items(),reverse=True, key = lambda x:x[1])][0:10] #tenth highest degree nodes</span>
        <span class="c1"># print([(k,v) for k, v in sorted(d.items(), reverse=True, key=lambda x: x[1])][0:10])</span>
        <span class="c1"># CLASSICAL DEGREE NOTION</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">degrees_partition</span><span class="p">()</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">degree</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">S</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
    <span class="n">nb_paths_to_compute</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of paths to compute :&quot;</span><span class="p">,</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="n">cnt_1_hop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_multi_hops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cnt_inf_dist</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">########</span>
    <span class="n">id_wcc_to_augmented_neighborhood</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">id_wcc_to_node_presence</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">id_wcc_to_links</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">list_id_wcc</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">index_node_to_wcc</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">list_id_wcc</span><span class="p">:</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">load_wcc</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">dict_offset_wcc</span><span class="p">,</span> <span class="n">wcc_storage_path</span><span class="p">)</span>
        <span class="n">node_presence</span> <span class="o">=</span> <span class="n">get_node_presence</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">compute_augmented_neighborhood</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">node_presence</span><span class="o">=</span><span class="n">node_presence</span><span class="p">)</span>
        <span class="n">id_wcc_to_node_presence</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_presence</span>
        <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">id_wcc_to_links</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span> <span class="o">=</span> <span class="n">links</span>
    <span class="c1">#######</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">compute_distances</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span>
                              <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">,</span>
                              <span class="n">id_wcc_to_node_presence</span><span class="p">)</span>
        <span class="c1"># D,A = compute_distances_and_duration_FSP(u, index_node_to_wcc,</span>
        <span class="c1">#                       id_wcc_to_augmented_neighborhood,</span>
        <span class="c1">#                       id_wcc_to_node_presence)</span>
        <span class="n">P</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">compute_path_FSP</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">index_node_to_wcc</span><span class="p">,</span>
                                   <span class="n">id_wcc_to_augmented_neighborhood</span><span class="p">,</span>
                                   <span class="n">id_wcc_to_node_presence</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">u</span><span class="p">:</span>
                <span class="c1"># if v in P and P[v]:</span>
                <span class="c1">#     plot_shortest_path(P[v], S)</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                    <span class="n">cnt_inf_dist</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;No paths between &quot;, u, &quot; and &quot;, v, &quot; !&quot;)</span>
                <span class="k">elif</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cnt_1_hop</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Distance from &quot;, u, &quot; to &quot;, v, &quot; :&quot;, D[v])#,&quot; Duration : &quot;,A[v])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt_multi_hops</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># print(&quot;Distance from &quot;, u, &quot; to &quot;, v, &quot; :&quot;, D[v])#, &quot; Duration :&quot;,A[v])</span>
    <span class="n">time_end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Paths distances computed in &quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time per distance :&quot;</span><span class="p">,</span> <span class="n">time_end</span> <span class="o">/</span> <span class="n">nb_paths_to_compute</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None distances :&quot;</span><span class="p">,</span> <span class="n">cnt_inf_dist</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1 hop distances :&quot;</span><span class="p">,</span> <span class="n">cnt_1_hop</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Multi hop distances :&quot;</span><span class="p">,</span> <span class="n">cnt_multi_hops</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/2018/04/&quot;  # LIP6</span>
    <span class="c1"># __file__ = &quot;20180418&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Socio_Patterns/High_School_2013/&quot;</span>
    <span class="c1"># __file__ = &quot;High_School_2013&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Crawdad/Infocom/&quot;</span>
    <span class="c1"># __file__ = &quot;infocom&quot;</span>

    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/Crawdad/Rollernet/&quot;</span>
    <span class="n">__filedate__</span> <span class="o">=</span> <span class="s2">&quot;rollernet&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Enron/&quot;</span>
    <span class="c1"># __file__ = &quot;enron&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Bitcoin/bitcoin_otc/&quot;</span>
    <span class="c1"># __file__ = &quot;bitcoin_otc&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/&quot;</span>
    <span class="c1"># __filedate__ = &quot;sg_generated&quot;</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/CODE/Straph/examples/&quot;</span>
    <span class="c1"># __file__ = &quot;example_path&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Socio_Patterns/High_School_2013/&quot;</span>
    <span class="c1"># __file__ = &quot;High_School_2013&quot;</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/example_paper/&quot;</span>
    <span class="c1"># __file__ = &quot;example_paper&quot;</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/CODE/Straph/examples/&quot;</span>
    <span class="c1"># __file__ = &quot;example_path&quot;</span>

    <span class="n">wcc_storage_path</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_wcc_storage/wcc.scf&quot;</span>

    <span class="c1"># S = sg.read_stream_graph(path_links=__directory__+__file__+&quot;_links.sg&quot;,</span>
    <span class="c1">#                          path_nodes=__directory__+__file__+&quot;_nodes.sg&quot;)</span>
    <span class="c1"># S.transform_links_label_to_int()</span>
    <span class="c1"># S.write_to_sgf(__directory__ + __file__ + &quot;_ordered_links.sgf&quot;)</span>
    <span class="c1"># S.plot()</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">read_stream_graph_from_sgf</span><span class="p">(</span><span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_ordered_links.sgf&quot;</span><span class="p">)</span>
    <span class="c1"># S.plot()</span>

    <span class="c1"># S.transform_links_label_to_int()</span>
    <span class="c1"># S.write_to_sgf(__directory__ + __file__)</span>
    <span class="c1"># S.plot()</span>
    <span class="c1"># plt.show()</span>

    <span class="c1"># S.transform_links_label_to_int()</span>
    <span class="c1"># S.plot()</span>
    <span class="c1">######################################</span>
    <span class="c1">#   Shortest PATH SS                 #</span>
    <span class="c1">######################################</span>
    <span class="n">index_node_to_wcc</span> <span class="o">=</span> <span class="n">construct_index_node_to_wcc</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">)</span>
    <span class="n">dict_offset_wcc</span> <span class="o">=</span> <span class="n">compute_dict_offset_wcc</span><span class="p">(</span><span class="n">wcc_storage_path</span><span class="p">)</span>

    <span class="n">source</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="c1"># shortest_paths,distance = compute_shortest_path(wcc_storage_path, index_node_to_wcc,source,destination)</span>
    <span class="c1"># print(&quot;Shortest Path between &quot;,source,&quot; and &quot;,destination,&quot; (distance = &quot;,distance,&quot;): &quot;)</span>
    <span class="c1"># print(shortest_paths)</span>
    <span class="c1"># for p in shortest_paths:</span>
    <span class="c1">#     plot_shortest_path(p,S)</span>
    <span class="c1"># plt.show()</span>
    <span class="c1">######################################</span>
    <span class="c1">#    Shortest PATH FUZZING           #</span>
    <span class="c1">######################################</span>
    <span class="c1"># fuzz_shortest_path(S, wcc_storage_path, index_node_to_wcc,high_degree_nodes=True)</span>
    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_shortest_path(S,wcc_storage_path,index_node_to_wcc)&quot;)</span>

    <span class="c1">######################################</span>
    <span class="c1">#   ALL Shortest PATH SS             #</span>
    <span class="c1">######################################</span>

    <span class="c1"># shortest_paths,distance = compute_all_shortest_paths(wcc_storage_path, index_node_to_wcc,source,</span>
    <span class="c1">#                                                         destination)</span>
    <span class="c1"># print(&quot;Shortest Paths between &quot;,source,&quot; and &quot;,destination,&quot; (distance = &quot;,distance,&quot;): &quot;)</span>
    <span class="c1"># print(shortest_paths)</span>
    <span class="c1"># for p in shortest_paths:</span>
    <span class="c1">#     plot_shortest_path(p,S)</span>
    <span class="c1"># plt.show()</span>

    <span class="c1">######################################</span>
    <span class="c1">#       ALL SHORTEST PATHS FUZZING   #</span>
    <span class="c1">######################################</span>
    <span class="c1"># fuzz_all_shortest_paths(S, wcc_storage_path, index_node_to_wcc,high_degree_nodes=True)</span>
    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_all_shortest_paths(S,wcc_storage_path,index_node_to_wcc,high_degree_nodes=True)&quot;,</span>
    <span class="c1"># snakeviz=True)</span>

    <span class="c1">######################################</span>
    <span class="c1">#       ALL DISTANCES FUZZING        #</span>
    <span class="c1">######################################</span>

    <span class="c1"># plt.show()</span>
    <span class="c1"># profile_shit(None,</span>
    <span class="c1">#              &quot;fuzz_latencies_wu(S, wcc_storage_path, index_node_to_wcc,dict_offset_wcc)&quot;,</span>
    <span class="c1">#              snakeviz=True)</span>
    <span class="n">profile_shit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                 <span class="s2">&quot;fuzz_distances(S, wcc_storage_path, index_node_to_wcc,dict_offset_wcc,high_degree_nodes=True)&quot;</span><span class="p">,</span>
                 <span class="n">snakeviz</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># S.plot()</span>
    <span class="c1"># plt.show()</span>

    <span class="c1">######################################</span>
    <span class="c1">#   Shortest PATH PairWise           #</span>
    <span class="c1">######################################</span>
    <span class="c1"># t_b = time.time()</span>
    <span class="c1"># print(&quot;Number of nodes :&quot;, len(S.nodes))</span>
    <span class="c1"># print(&quot;Number of sg nodes :&quot;,sum([len(n)/2 for n in S.node_presence]))</span>
    <span class="c1"># print(&quot;Number of links :&quot;,len(S.links))</span>
    <span class="c1"># print(&quot;Number of sg links :&quot;,sum([len(n)/2 for n in S.link_presence]))</span>
    <span class="c1"># W = test_sp_pairwise(S,wcc_storage_path)</span>
    <span class="c1"># values =[]</span>
    <span class="c1"># for i in range(W.shape[0]):</span>
    <span class="c1">#     for j in range(W.shape[1]):</span>
    <span class="c1">#         if W[i,j] != 0:</span>
    <span class="c1">#             values.append(W[i,j])</span>
    <span class="c1"># # print(&quot;W :&quot;,W)</span>
    <span class="c1"># print(&quot;Mean :&quot;,sum(values)/len(values))</span>
    <span class="c1"># print(&quot;Max :&quot;,max(values))</span>
    <span class="c1"># # plt.show()</span>
    <span class="c1"># print(&quot;Time taken :&quot;,time.time()-t_b)</span>
    <span class="c1"># exit()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2019, Eol Ournan.
      Last updated on Oct 22, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>